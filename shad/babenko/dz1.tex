\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\textheight=220mm
\textwidth=160mm

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm 
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 1-1.}
\paragraph{Описание алгоритма.}





\section{Задача 1-2.} 
\paragraph{Описание алгоритма.}
И так нам задана строка $ \alpha = \alpha_0, \alpha_1, ..., \alpha_n$ состоящяя
из символов алфавита 
$ A = \left\{ 
    \mbox{\footnotesize{`(', `)', `[', `]', `\{', `\}'}}
\right\} $.

Нам следует узнать максимальную длину префикса $ p_{\alpha} = \alpha_0, \alpha_1, ..., \alpha_k \;\;\; k \le n$, такого, что он является
правильной скобочно последовательностью, либо его можно продлить до таковой. Для этого будем использовать стек $ S $,
который поможет нам идентифицировать <<уровень>> скобочности на текущий момент способом
описанным ниже.

Назовем скобку $ c^{-1} $ обратной скобке $ c $, если эти строка $ cc^{-1} $ образует правильную скобочную последовательность.
Заметим, что обратные скобки есть только у открывающихся скобок по определению.

Пройдем по символам строки $ \alpha $ и на каждом следующем символе будем класть, либо доставать элемент из $ S $, а именно:
если встретилась открытая cкобка $ \alpha_i $, делаем $ S.push(\alpha_i^{-1}) $, если встретилась скобка $\alpha_i^{-1}$, сравним ее 
с $ S.pop() $.

Таким образом, каждый раз когда мы проводим операцию $ push $ мы заходим глубже на один уровень во вложенности скобок, в
конце этого уровня мы ожидаем скобку $ c^{-1} $
Очевидно, что как только $ S.pop() $ не будет равняться текущему $ \alpha_i^{-1} $, или $ S $ в момент сравнения окажется пустым, 
то далее последовательность уже не будет правильной и тогда длинна префикса который еще можно продлить до правильной скобочной 
последовательности будет i. (так как символы строки индексировались с 0).

Если мы прошли всю строку и в конце стек оказался пуст. То вместо i следует вывести $ CORRECT $, так как полседовательность оказалась правильной.


\paragraph{Алгоритм по шагам.}
\begin{enumerate}
    \item $i = 0; S = std::stack() $
    \item если $ i \le n $, переходим к следующему шагу, в противном случае к шагу 6
    \item если $ \alpha_i $ открытая скобка, то переходим к шагу 4, в противном случае переходим к шагу 5.
    \item $ S.push(\alpha_i^{-1}) $. Переходим к шагу 2.
    \item если $ S.pop() \ne \alpha_i $, то $ ++i $ переходим к шагу 2, переходим к шагу 6.
    \item если $ i = \alpha.size() \mbox{ and } S.empty() $, вернуть $ CORRECT $, иначе вернуть $ i $.
\end{enumerate}

В итоге сложность по времени $O(n)$. Алгоритм требует $O(n)$ дополнительной памяти.


\paragraph{Доказательство.}
Для начала рассмотрим случай, что алгоритм прошел по всему $ \alpha $ и $ S $ оказался пуст.

То, что каждой открывающейся скобке соответствует закрывающаяся, находящаяся правее ее, скобка следует
из того, что $ S $ пуст. Тогда выбросим из $ \alpha $ все <<тривиальные>> правильные последовательности вида
$cc^{-1}$, получим $ \alpha^{(1)} $. 
Проделаем то же самое с $ \alpha^{1} $... и так далее пока не получим
$ \alpha^{k} $ последовательность без <<тривиальных>> правильных подпоследовательностей. 

Если $ \alpha^{k} $ не пусто, то в определенном месте должна быть неправильная скобочная подпоследовательность из двух символов:
$ c_1c_2 \;\;\;\; c_1^{-1} \ne c_2 $. Но тогда дойдя до $ c_2 $ в $ \alpha \;\;\;\; S.pop() \ne c_2 $, следовательно
алгоритм остановится, последовательность $ \alpha $ пройдена не полностью, что есть противоречие.

В случае когда $ S $ не пуст, очевидно, что либо $ \alpha $ закончилась, либо $ S.pop() \ne \alpha_i $. В первом случае
мы можем легко достроить $ \alpha $ до правильной скобочной последовательности, кладя в нее элементы из $ S $. Во втором,
очевидно, что $ \alpha_0\dots \alpha_i $ не является правильной скобочной последовательностью, зато мы легко можем
достроить $ \alpha_0\dots \alpha_{i-1} $ до правильной описанным выше способом. 




\section{Задача 1-4.} 
\paragraph{Описание алгоритма.}
Заведем очередь $ Q $ с поддержкой максимума. В начале инициализируем ее 1-ым элементом входной последовательности, 
теперь когда нам будет встречаться управляющий символ $ R $, будем перемещать правый
итератор и класть число под ним в очередь $ Q $. Если же встечается символ $ L $, будем извлекать 
элемент из очереди $ Q $.

Поддерживать максимум в очереди будем схожим образом с поддержкой минимума в очереди, а именно заведем 2 стека с 
поддержкой максимума. Стоит лишь сказать, что нам не нужны элементы очереди(они и так есть между L и R), 
а нужны только максимумы, которые будут в двух стеках $ S_1 $ и $ S_2 $. 


\paragraph{Алгоритм по шагам}
\begin{enumerate}
    \item $ std::vector<int> \;\;\; data \leftarrow $ входная последовательность \\
          $ std::vector<int>::iterator \;\;\; rightIterator = data.begin() $ \\
          $ std::vector<int>::iterator \;\;\; leftIterator = data.begin() $ \\
          $ std::stack<int> \;\;\; S_1, S_2 $ \\
          $ S_1.push(data[0]) $
    \item $ command \leftarrow $ символ управляющей последовательности из входного потока.
          Если читать нечего, то переходим к шагу 7.
    \item Если $ command = R $, то   ++$rightIterator $ и переходим к шагу 4, иначе ++$leftIterator$ и переходим к шагу 5.
    \item $ S_1.push(\max(S_1.top(), *rightIterator)) $, выводим $ \max(S_1.top(), S_2.top()) $, переходим к шагу 2.
    \item Если $ ! S_2.empty() $, то $ S_2.pop() $, выводим $ \max(S_1.top(), S_2.top()) $ и переходим к шагу 2,
          в противном случае переходим к шагу 6.
    \item Перекладываем по очереди все элементы из $ S_1 $ в $ S_2 $, также с сохранением максимума, переходим к шагу 5.
    \item Конец.
\end{enumerate}

В итоге сложность по времени $ O(n) $, алгоритм требует $ O(n) $ дополнительной памяти.

\end{document}
