\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm 
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 1-1.}
\paragraph{Описание алгоритма.}
Прибегнем к помощи методов динамического программирования для решения задачи.

У нас есть последовательность $ \alpha = \alpha_0\alpha_1\dots\alpha_{n-1} $. 
Заведем 2 вектора: $ maxLength $ и $ p $. В $ maxLength[i] $ будем хранить
максимальную длину чередующейся подпоследовательности для $ \alpha_0\dots\alpha_i $.
В $ p[i] $ будем хранить предыдущий элемент для $ \alpha_i $ в максимальной
чередующейся подпоследовательности которая заканчивается в $ \alpha_i $.

Инициализируем $ maxLength $ единицами, а $ p $ значениями $ \NA $.
Пробежим по элементам $ \alpha $, от первого до последнего, для каждого элемента
$ \alpha_i $ найдем значения $ maxLength[i] $ и $ p[i] $. Для этого 
пробежим по элементам от $ \alpha_0 $ до $ \alpha_{i - 1} $ и выберем самый левый
элемент, такой что:
$$ 
    \max\limits_{\tiny\begin{array}{c} j \in [0; i - 1] \\ \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{p[j]}) \\ \alpha_i \ne \alpha_j \end{array} } (maxLength(j))
$$
Здесь $ \sgn $ - это сигнум. Стоит заметить, что в случае когда $ p[j] = \NA $, условие $ \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{p[j]}) $ опускается.

В конце выбираем самый левый максимум в $ maxLength $ и восстанавливаем последовательность с помощью $ p $.


\paragraph{Алгоритм по шагам.}
\begin{enumerate}
    \item $ n \leftarrow \alpha.size() $ \\
          $ \NA \leftarrow static\_cast<size_t> (-1)$ \\
          $ std::vector<size\_t> p \leftarrow std::vector<size\_t>(n, \NA) $ \\
          $ std::vector<size\_t> maxLength \leftarrow std::vector<size\_t>(n, \NA)$
          $ i \leftarrow 0 $
    \item Если $ i < n $, то переходим к следующему шагу, иначе шаг 8.
    \item $ j \leftarrow 0 $
    \item Если $ j < i $, то переходим к следующему шагу, иначе шаг 2.
    \item Если $ maxLength[i] \le maxLength[j] \mbox{   and   } (p[j] = \NA \mbox{   or   } \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{p[j]}) $,
          то ++$maxLength[i]$, $ p[i] \leftarrow j $.
    \item ++$j$, переходим к шагу 4
    \item ++$i$, переходим к шагу 2.
    \item Берем самый левый максимум из $ maxLength $, восстанавливаем последовательность с помощью $ p $.
    \item Переворачиваем восстановленую последовательность. Выводим на экран.
\end{enumerate}


\paragraph{Доказательство.}
Будем доказывать по индукции от числа элементов во входной последовательности. Для 1, очевидно, верно.
Предположим, что алгоритм работает верно для входной последовательности $ \alpha_0 \dots \alpha_{n - 1} $,
докажем, что для $ n + 1 $ он работает также верно.
$\alpha_n$ присоеденится к какой-либо уже имеющейся последовательности(если только входная последовательность
не состоит из одинаковых элементов). Если эта последовательность будет длиннее уже имеющейся, то алгоритм
выберет ее как максимальную. Если будет равна текущей, то алгортм оставит старую по лексикографическому
признаку. Если присоеденится к меньшей чем максимальная подпоследовательность из $ \alpha_0 \dots \alpha_{n - 1} $,
то, очевидно, что оставит старую. Таким образом алгоритм работает верно для последовательности из $ n + 1 $ чисел.


\paragraph{Сложность}
В итоге сложность по времени $ O(n^2) $, алгоритм требует $ O(n) $ дополнительной памяти.




\section{Задача 1-2.} 
\paragraph{Описание алгоритма.}
И так нам задана строка $ \alpha = \alpha_0, \alpha_1, ..., \alpha_n$ состоящяя
из символов алфавита 
$ A = \left\{ 
    \mbox{\footnotesize{`(', `)', `[', `]', `\{', `\}'}}
\right\} $.

Нам следует узнать максимальную длину префикса $ p_{\alpha} = \alpha_0, \alpha_1, ..., \alpha_k \;\;\; k \le n$, такого, что он является
правильной скобочно последовательностью, либо его можно продлить до таковой. Для этого будем использовать стек $ S $,
который поможет нам идентифицировать <<уровень>> скобочности на текущий момент способом
описанным ниже.

Назовем скобку $ c^{-1} $ обратной скобке $ c $, если эти строка $ cc^{-1} $ образует правильную скобочную последовательность.
Заметим, что обратные скобки есть только у открывающихся скобок по определению.

Пройдем по символам строки $ \alpha $ и на каждом следующем символе будем класть, либо доставать элемент из $ S $, а именно:
если встретилась открытая cкобка $ \alpha_i $, делаем $ S.push(\alpha_i^{-1}) $, если встретилась скобка $\alpha_i^{-1}$, сравним ее 
с $ S.pop() $.

Таким образом, каждый раз когда мы проводим операцию $ push $ мы заходим глубже на один уровень во вложенности скобок, в
конце этого уровня мы ожидаем скобку $ c^{-1} $
Очевидно, что как только $ S.pop() $ не будет равняться текущему $ \alpha_i^{-1} $, или $ S $ в момент сравнения окажется пустым, 
то далее последовательность уже не будет правильной и тогда длинна префикса который еще можно продлить до правильной скобочной 
последовательности будет i. (так как символы строки индексировались с 0).

Если мы прошли всю строку и в конце стек оказался пуст. То вместо i следует вывести $ CORRECT $, так как полседовательность оказалась правильной.


\paragraph{Алгоритм по шагам.}
\begin{enumerate}
    \item $i = 0; S = std::stack() $
    \item если $ i \le n $, переходим к следующему шагу, в противном случае к шагу 6
    \item если $ \alpha_i $ открытая скобка, то переходим к шагу 4, в противном случае переходим к шагу 5.
    \item $ S.push(\alpha_i^{-1}) $. Переходим к шагу 2.
    \item если $ S.pop() \ne \alpha_i $, то $ ++i $ переходим к шагу 2, переходим к шагу 6.
    \item если $ i = \alpha.size() \mbox{ and } S.empty() $, вернуть $ CORRECT $, иначе вернуть $ i $.
\end{enumerate}


\paragraph{Доказательство.}
Для начала рассмотрим случай, что алгоритм прошел по всему $ \alpha $ и $ S $ оказался пуст.

То, что каждой открывающейся скобке соответствует закрывающаяся, находящаяся правее ее, скобка следует
из того, что $ S $ пуст. Тогда выбросим из $ \alpha $ все <<тривиальные>> правильные последовательности вида
$cc^{-1}$, получим $ \alpha^{(1)} $. 
Проделаем то же самое с $ \alpha^{1} $... и так далее пока не получим
$ \alpha^{k} $ последовательность без <<тривиальных>> правильных подпоследовательностей. 

Если $ \alpha^{k} $ не пусто, то в определенном месте должна быть неправильная скобочная подпоследовательность из двух символов:
$ c_1c_2 \;\;\;\; c_1^{-1} \ne c_2 $. Но тогда дойдя до $ c_2 $ в $ \alpha \;\;\;\; S.pop() \ne c_2 $, следовательно
алгоритм остановится, последовательность $ \alpha $ пройдена не полностью, что есть противоречие.

В случае когда $ S $ не пуст, очевидно, что либо $ \alpha $ закончилась, либо $ S.pop() \ne \alpha_i $. В первом случае
мы можем легко достроить $ \alpha $ до правильной скобочной последовательности, кладя в нее элементы из $ S $. Во втором,
очевидно, что $ \alpha_0\dots \alpha_i $ не является правильной скобочной последовательностью, зато мы легко можем
достроить $ \alpha_0\dots \alpha_{i-1} $ до правильной описанным выше способом. 


\paragraph{Сложность.}
В итоге сложность по времени $O(n)$. Алгоритм требует $O(n)$ дополнительной памяти.




\section{Задача 1-3.} 
\paragraph{Описание алгоритма.}
Будем говорить, что куб $ A $ меньше чем куб $ B $, или $ A < B $, если для любой стороны $ a $, куба $ A $,
и любой стороны $ b $, куба $ B $, выполнено равенство: $ a < b $.
Очевидно, что $ A $ можно вложить в куб $ B $, тогда и только тогда, когда $ A < B $.

Тогда, строго говоря, входная последовательность кубов не упорядочена по убыванию, так как она упорядочена лишь
по самой короткой стороне кубов. 

Сведем нашу задачу к следующей: Дана входная последовательность кубов $A_0..A_{n-1}$.
Нужно найти длину наибольшей возрастающей подпоследовательности кубов во входной последовательности.

\paragraph{Шаги алгоритма.}
\begin{enumerate}
    \item $ std::vector<Cube> cubes \leftarrow входная последовательность $ \\
          $ n \leftarrow cubes.size() $ \\
          $ std::vector<size\_t> maxLengthOfLIS \leftarrow std::vector<size\_t>(n, 1)$ \\
          $ i \leftarrow 0 $
    \item Если $ i < n $, то следующий шаг, иначе шаг 7.
    \item $ j \leftarrow 0 $
    \item Если $ j < i $, то следующий шаг, иначе шаг 2.
    \item Если $ cubes[j] < cubes[i] \mbox{   and   } maxLengthOfLIS[j] >= maxLengthOfLIS[i] $, тогда ++$ maxLengthOfLIS[i] $.
    \item ++$j$, переходим к шагу 4.
    \item Выводим на экран $ maxLengthOfLIS[n - 1] $.
\end{enumerate}


\paragraph{Доказательство.}
Допустим, что можно найти максимальную последовательность вложенных кубов $ A_{i_0} \dots A_{i_{k-1}} $, такую, что она больше
чем максимальная возрастающая подпоследовательность $ A_{j_0} \dots A_{j_{ans - 1}} $ входной последовательности кубов.
То есть $ ans < k $.

Так как кубы $ A_{i_0} \dots A_{i_{k-1}} $ вложены друг в друга, то $ A_{i_0} < A_{i_1} < \dots < A_{i_{k-1}} $. Стоит также
заметить, что так как кубы упорядочены по возрастанию, то их самые короткие стороны тоже упорядочены по возрастанию.
Из этого следует, что во входной последовательности кубы $ A_{i_0} \dots A_{i_{k-1}} $ тоже упорядочены по возрастанию, то
есть $ i_0 < i_1 < \dots < i_{k-1} $. Отсюда следует, что последовательность $ A_{i_0} \dots A_{i_{k-1}} $ является вложенной
подпоследовательностью входной последовательности кубов. Селодовательно $ ans \ge k $ -- противоречее.


\paragraph{Сложность.}
В итоге сложность по времени $ O(n^2) $, алгоритм требует $ O(n) $ дополнительной памяти.




\section{Задача 1-4.} 
\paragraph{Описание алгоритма.}
Заведем очередь $ Q $ с поддержкой максимума. В начале инициализируем ее 1-ым элементом входной последовательности, 
теперь когда нам будет встречаться управляющий символ $ R $, будем перемещать правый
итератор и класть число под ним в очередь $ Q $. Если же встечается символ $ L $, будем извлекать 
элемент из очереди $ Q $.

Поддерживать максимум в очереди будем схожим образом с поддержкой минимума в очереди, а именно заведем 2 стека с 
поддержкой максимума. Стоит лишь сказать, что нам не нужны элементы очереди(они и так есть между L и R), 
а нужны только максимумы, которые будут в двух стеках $ S_1 $ и $ S_2 $. 


\paragraph{Алгоритм по шагам}
\begin{enumerate}
    \item $ std::vector<int> \;\;\; data \leftarrow $ входная последовательность \\
          $ std::vector<int>::iterator \;\;\; rightIterator = data.begin() $ \\
          $ std::vector<int>::iterator \;\;\; leftIterator = data.begin() $ \\
          $ std::stack<int> \;\;\; S_1, S_2 $ \\
          $ S_1.push(data[0]) $
    \item $ command \leftarrow $ символ управляющей последовательности из входного потока.
          Если читать нечего, то переходим к шагу 7.
    \item Если $ command = R $, то   ++$rightIterator $ и переходим к шагу 4, иначе ++$leftIterator$ и переходим к шагу 5.
    \item $ S_1.push(\max(S_1.top(), *rightIterator)) $, выводим $ \max(S_1.top(), S_2.top()) $, переходим к шагу 2.
    \item Если $ ! S_2.empty() $, то $ S_2.pop() $, выводим $ \max(S_1.top(), S_2.top()) $ и переходим к шагу 2,
          в противном случае переходим к шагу 6.
    \item Перекладываем по очереди все элементы из $ S_1 $ в $ S_2 $, также с сохранением максимума, переходим к шагу 5.
    \item Конец.
\end{enumerate}


\paragraph{Доказательство.}
По построению верно.


\paragraph{Сложность.}
В итоге сложность по времени $ O(n) $, алгоритм требует $ O(n) $ дополнительной памяти.

\end{document}
