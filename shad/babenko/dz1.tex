\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\textheight=220mm
\textwidth=160mm

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm 
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 1-2.} 

\paragraph{Описание алгоритма.}И так нам задана строка $ \alpha = \alpha_0, \alpha_1, ..., \alpha_n$ состоящяя
из символов алфавита 
$ A = \left\{ 
    \mbox{\footnotesize{`(', `)', `[', `]', `\{', `\}'}}
\right\} $.

Нам следует узнать максимальную длину префикса $ p_{\alpha} = \alpha_0, \alpha_1, ..., \alpha_k \;\;\; k \le n$, такого, что он является
правильной скобочно последовательностью, либо его можно продлить до таковой. Для этого будем использовать стек $ S $,
который поможет нам идентифицировать <<уровень>> скобочности на текущий момент способом
описанным ниже.

Назовем скобку $ c^{-1} $ обратной скобке $ c $, если эти строка $ cc^{-1} $ образует правильную скобочную последовательность.
Заметим, что обратные скобки есть только у открывающихся скобок по определению.

Пройдем по символам строки $ \alpha $ и на каждом следующем символе будем класть, либо доставать элемент из $ S $, а именно:
если встретилась открытая cкобка $ \alpha_i $, делаем $ S.push(\alpha_i^{-1}) $, если встретилась скобка $\alpha_i^{-1}$, сравним ее 
с $ S.pop() $.

Таким образом, каждый раз когда мы проводим операцию $ push $ мы заходим глубже на один уровень во вложенности скобок, в
конце этого уровня мы ожидаем скобку $ c^{-1} $
Очевидно, что как только $ S.pop() $ не будет равняться текущему $ \alpha_i^{-1} $, или $ S $ в момент сравнения окажется пустым, 
то далее последовательность уже не будет правильной и тогда длинна префикса который еще можно продлить до правильной скобочной 
последовательности будет i. (так как символы строки индексировались с 0).

Если мы прошли всю строку и в конце стек оказался пуст. То вместо i следует вывести $ CORRECT $, так как полседовательность оказалась правильной.

Запишем теперь шаги алгоритма:
\begin{enumerate}
    \item $i = 0; S = std::stack() $
    \item если $ i \le n $, переходим к следующему шагу, в противном случае к шагу 6
    \item если $ \alpha_i $ открытая скобка, то переходим к шагу 4, в противном случае переходим к шагу 5.
    \item $ S.push(\alpha_i^{-1}) $. Переходим к шагу 2.
    \item если $ S.pop() \ne \alpha_i $, то $ ++i $ переходим к шагу 2, переходим к шагу 6.
    \item если $ i = \alpha.size() \mbox{ and } S.empty() $, вернуть $ CORRECT $, иначе вернуть $ i $.
\end{enumerate}

В итоге сложность по времени: $O(n)$


\paragraph{Доказательство.}
Для начала рассмотрим случай, что алгоритм прошел по всему $ \alpha $ и $ S $ оказался пуст.

То, что каждой открывающейся скобке соответствует закрывающаяся, находящаяся правее ее, скобка следует
из того, что $ S $ пуст. Тогда выбросим из $ \alpha $ все <<тривиальные>> правильные последовательности вида
$cc^{-1}$, получим $ \alpha^{(1)} $. 
Проделаем то же самое с $ \alpha^{1} $... и так далее пока не получим
$ \alpha^{k} $ последовательность без <<тривиальных>> правильных подпоследовательностей. 

Если $ \alpha^{k} $ не пусто, то в определенном месте должна быть неправильная скобочная подпоследовательность из двух символов:
$ c_1c_2 \;\;\;\; c_1^{-1} \ne c_2 $. Но тогда дойдя до $ c_2 $ в $ \alpha \;\;\;\; S.pop() \ne c_2 $, следовательно
алгоритм остановится, последовательность $ \alpha $ пройдена не полностью, что есть противоречие.

В случае когда $ S $ не пуст, очевидно, что либо $ \alpha $ закончилась, либо $ S.pop() \ne \alpha_i $. В первом случае
мы можем легко достроить $ \alpha $ до правильной скобочной последовательности, кладя в нее элементы из $ S $. Во втором,
очевидно, что $ \alpha_0\dots \alpha_i $ не является правильной скобочной последовательностью, зато мы легко можем
достроить $ \alpha_0\dots \alpha_{i-1} $ до правильной описанным выше способом. 



\end{document}
