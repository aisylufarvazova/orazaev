\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
\newcommand{\LCS}{\operatorname{LCS}}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 4-4.}
\paragraph{Описание алгоритма.}
На вход подано $ n $ треугольников $ t \in T $, записанных
в виде длинн сторон: $ t = <t_1, t_2, t_3> $. Требуется определить
число классов подобия среди входного множества треугольников $ T $.

Во время чтения из стандартного потока - перед тем как решить
поставленную задачу - выполним шаг препроцессинга:
\begin{enumerate}
    \item Отсортируем стороны треугольника по возрастанию и далее
          будем считать, что для любого $ t \in T $, $ t_1 \le t_2 \le t_3 $.

    \item Нормализуем стороны треугольника, найдем
          $ d = \gcd(\gcd(t_1, t_2), t_3) $. Поделим все стороны на их
          наибольший общий делитель: $ t_i = t_i / d \mbox{, } i = 1, 2, 3 $.

\end{enumerate}

Только после препроцессинга положим треугольник в массив входных данных
$ data $.

Далее решить задачу нам поможет алгоритм совершенного хэширования FKS.
Пользуясь тем, что число входных треугольников ограничено $ n \le 10^6 $,
возьмем размер хэш-таблицы первого уровня $ N = 10^6 + 3 $ - первое простое
большее $ 10^6 $.

Нам потребуется уневерсальное семейство хэш функций, в качестве которого
выберем следующее:
$$
\mathfrak{H} = \{ h_c: c = <c_1, c_2, c_3>,
h_c(t) = \sum_{i=1}^3 c_i \cdot t_i (\mod N) \}
$$
, где $ 0 < c_j < N $, для $  0 < j \le 3 $.

Из этого семейства, на имеющемся обработанном входном массиве $ data $
пробуем строить хэш-таблицу случайно выбрав $ h \in \mathfrak{H} $
, попутно считая количество занятых слотов $ size $.

Если не получилось - сумма квадратов числа коллизий в хэш-таблице первого
уровня оказалась больше $ 3N $ - сбрасываем $ size $ в 0, очищаем занятые слоты,
и выбрав новую случаюную $ h \in \mathfrak{H} $ снова пробуем строить таблицу.

Бороться с той неприятностью, что у нас не множество ключей, а мультимножество
будем следующим образом: Заполнять хэш-таблицы второго уровня будем по мере
подбора хэш функции первого уровня перехэшируя их(хэш-таблицы второго уровня)
по мере надобности.  Учитывая то, что мат. ожидание числа коллизий
для конкретного ключа $ x $ меньше $ 10^6 / (10^6 + 3) \approx 1$
(и это только в таблице первого уровня), можно говорить, что это не скажется
на линейном времени работы в среднем.

Это поможет нам динамически заполнять таблицу, даже если встречается ключ,
который уже был(подобный треугольник).

Стоит ради оптимизации по памяти хранить как ключи в хэш-таблицах
второго уровня не полностью $ t $(3 числа), а только индекс в $ data $.

Когда таблицу удастся построить, просто выводим число занятых в ней слотов
$ size $ в выходной поток.

\paragraph{Доказательство.}
Все хорошие оценки и числа aлгоритма упираются в два утверждения:
\begin{enumerate}
    \item Шаг препроцессинга однозначно определяет классы
          подобных треугольников. То есть если существует два
          треугольника $ a, b \in T $, то после определенного выше
          препроцессинга
          $ P $, $ P(a) = P(b) \Leftrightarrow a \mbox{ и } b \mbox{ подобны} $

    \item Семейство хэш функций $ \mathfrak{H} $ -- универсальное семейство
          хэш функций.
\end{enumerate}

Первое утверждение верно, так как операция деления всех сторон на одно и
тоже число переводит подобные треугольники в подобные, а также потому что
для двух подобных треугольников $ a $ и $ b $, если $ \gcd(a_1, a_2, a_3) =
\gcd(b_1, b_2, b_3) $, то $ a_i == b_i $(стороны отсортированы по возрастанию).

Докажем второе утверждение. Возьмем любые $ x, y \in T $, что $ x \ne y $.
Найдем вероятность события того, что $ h(x) == h(y) $ для случайно
выбранной $ h \in \mathfrak{H} $ - $ Pr[h(x) = h(y)] $.

Рассмотрим следующую цепочку рассуждений:
$$
h(x) == h(y) \Leftrightarrow \sum\limits_{i = 1}^3 c_i x_i
\equiv \sum\limits_{i = 1}^3 c_i y_i (\mod N)
$$
Далее без ограничения общности, так как мы можем поменять
коэффициенты $ c $ местами, мы можем выделить первый член из сумм:
$$
c_1 x_1 + \sum\limits_{i = 2}^3 c_i x_i \equiv
c_1 y_1 + \sum\limits_{i = 2}^3 c_i y_i (\mod N)
\Leftrightarrow
$$
$$
\Leftrightarrow
c_1(x_1 - y_1) \equiv \sum\limits_{i = 2}^3 c_i (y_i - x_i) (\mod N)
\Leftrightarrow
$$
$$
\Leftrightarrow
c_1 \equiv \left(\sum\limits_{i = 2}^3 c_i (y_i - x_i)\right)
(x_1 - y_1)^{-1} (\mod N)
$$

Из теории чисел известно, что в кольце по модулю простого числа всегда
существует обратный элемент, а таже этот элемент единственнен. Мы взяли
N простым. Это означает, что мы можем только одним способом выбрать $ c_1 $,
чтобы получить коллизию. Значит число возможных способов выбрать хэш-функцию
c коллизией для $ x, y $ $ N^2 \cdot 1 $, когда число возможных способов
выбрать хэш-функцию $ N^3 $. Отсюда следует:
$$
Pr(h(x) = h(y)) = \frac{N^2}{N^3} = \frac{1}{N}
$$

Универсальность доказана.

Докажем первое утверждение. Допустим $ P(a) = P(b) $ и при этом $ a $ и $ b $
не подобны друг другу. Тогда $ a_i / b_i \ne a_j / b_j $ для любых $ i \ne j $,
$ 0 \le i, j \le 3 $. 



\paragraph{Сложность}
Если принебречь сложностью 2-х алгоритмов евклида и сортировки 3-х
элементного массива, загнав все в константу, то в среднем сложность
по времени будет $ O(n) $.

Алгоритм требует $ O(n) $ дополнительной памяти.

\end{document}
