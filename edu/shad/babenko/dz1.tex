\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm 
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 1-1.}
\paragraph{Описание алгоритма.}
Прибегнем к помощи методов динамического программирования для решения задачи.

У нас есть последовательность $ \alpha = \alpha_0\alpha_1\dots\alpha_{n-1} $.
Чередующаяся подпоследовательность $ \alpha_{x_0}\alpha_{x_1}...\alpha_{x_k} $ 
может быть 2-х видов: такая, что $ \alpha_{x_0} < \alpha_{x_1} $, а также такая, что
$ \alpha_{x_0} > \alpha_{x_1} $.  Заведем 2 вектора: $ V_< $ и $ V_> $, соответственно 
для каждого из видов возможных чередующихся подпоследовательностей.

В каждом будем хранить кортежи из 2-х элементов $(l, p)$, где $ V[i].l $ -- 
длина максимальной чередующейся подпоследовательности заканчивающейся в $ \alpha_i $, 
а $ V[i].p $ -- позиция предыдущего элемента для $ \alpha_i $ в максимальной 
чередующейся подпоследовательности, которая заканчивается в $ \alpha_i $.

Инициализируем $ V[i].l = 1, \;\;\; V[i].p = \NA $ для каждого элемента входной 
последовательности $ \alpha $, для обеих векторов $ V_< $ и $ V_> $.
Пробежим по элементам $ \alpha $, от первого до последнего, для каждого элемента
$ \alpha_i $ найдем значения $ V_<[i], \;\;\; V_>[i] $. Для этого пробежим по
элементам от $ \alpha_0 $ до $ \alpha_{i-1} $ и для $ V_< $ выберем самый левый элемент,
такой что:
$$ 
    \max\limits_{\tiny\begin{array}{c} j \in [0; i - 1] \\ \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{V_<[j].p}) \\ \alpha_i \ne \alpha_j \end{array} } (V_<[j].l)
$$
Здесь $ \sgn $ -- это сигнумю. Позицию $ j $ найденного элемента запишем в 
$ V_<[i].p $, а в $ V_<[i].l $ запишем $ V_<[j].l + 1 $, так как длинна 
чередующейся подпоследовательности увеличилась на 1.

Те же действия проделаем для $ V_> $. Стоит только заменить, что для наших векторов $ V_> $ и $ V_< $
условиe $ \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{p[j]}) $ будет изменено в случае когда 
$ V[j].p = \NA $. А конкретно, для $ V_< $, будет следующее условиe:
$ \alpha_j < \alpha_i $, а для $ V_> $ соответственно, будет $ \alpha_j > \alpha_i$

В конце выбераем самые левые максимумы $ i_< = \argmax\limits_{0 \le i < n}(V_<[i].l) $ 
и $ i_> = \argmax\limits_{0 \le i < n}(V_>[i].l) $. Восстанавливаем индексы подпоследовательностей c
помощью $ V_>[i_>].p $ и $ V_<[i_<].p $. Далее выбираем длиннейшую или в случае равной длинны
ту последовательность индексов, которая лексикографически раньше. 
Переворачиваем, выводим на экран элементы по выбранным индексам.


\paragraph{Алгоритм по шагам.}
\begin{enumerate}
    \item $ n \leftarrow \alpha.size() $ \\
          $ \NA \leftarrow static\_cast<size\_t> (-1)$ \\
          $ struct Element { size\_t l; size\_t p; } $ \\
          $ std::vector<Element> V_< \leftarrow std::vector<Element>(n, (1, \NA)) $\\
          $ std::vector<Element> V_> \leftarrow std::vector<Element>(n, (1, \NA)) $\\
          $ i \leftarrow 0 $
    \item Если $ i < n $, то переходим к следующему шагу, иначе шаг 9.
    \item $ j \leftarrow 0 $
    \item Если $ j < i $, то переходим к следующему шагу, иначе шаг 8.
    \item Если $ V_<[i].l \le V_<[j].l \mbox {    and    } [(V_<[j].p = \NA \mbox{    and   } \alpha_j < \alpha_i) $ \\
          $\mbox{   or   } (V_<[j].p \ne \NA \mbox{    and   } \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{V_<[j].p})] $, то \\   
          ++$V_<[i].l$, $\;\; V_<[i].p \leftarrow j $.
    \item Если $ V_>[i].l \le V_>[j].l \mbox {    and    } [(V_>[j].p = \NA \mbox{    and   } \alpha_j > \alpha_i) $ \\
          $\mbox{   or   } (V_>[j].p \ne \NA \mbox{    and   } \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{V_>[j].p})] $, то \\   
          ++$V_>[i].l$, $\;\; V_>[i].p \leftarrow j $.

    \item ++$j$, переходим к шагу 4
    \item ++$i$, переходим к шагу 2.
    \item Берем самый левый элемент из $ V_< $ c максимальным $ l $, восстанавливаем подпоследовательность с помощью
          поля $ p $ найденного элемента получаем индексы $ ANS_< $
    \item Берем самый левый элемент из $ V_> $ c максимальным $ l $, восстанавливаем подпоследовательность с помощью
          поля $ p $ найденного элемента получаем индексы $ ANS_> $
    \item Выбераем большую подпоследовательность из $ ANS_< $ и $ ANS_> $, в случае равенства выбираем ту, у которой
          меньше последний элемент, при равенстве, ту у которой меньше предпоследний элемент и так далее.
    \item Переворачиваем выбранную подпоследовательность. Выводим на экран.
\end{enumerate}


\paragraph{Доказательство.}
Докажем, что с помощью $ V_< $, мы восстановим наибольшую чередующуюся подпоследовательность, 
для которой ее первый элемент меньше второго.
Будем доказывать по индукции от числа элементов во входной последовательности. Для 1, очевидно, верно.
Предположим, что алгоритм работает верно для входной последовательности $ \alpha_0 \dots \alpha_{n - 1} $,
докажем, что для $ n + 1 $ он работает также верно.
$\alpha_n$ присоеденится к какой-либо уже имеющейся последовательности(если только входная последовательность
не состоит из одинаковых элементов). Если эта последовательность будет длиннее уже имеющейся, то алгоритм
выберет ее как максимальную. Если будет равна текущей, то алгортм оставит старую по лексикографическому
признаку. Если присоеденится к меньшей чем максимальная подпоследовательность из $ \alpha_0 \dots \alpha_{n - 1} $,
то, очевидно, что оставит старую. Таким образом все работает верно для последовательности из $ n + 1 $ чисел.

Для $ V_> $ можно провести аналогичные рассуждения. Таки образом мы определяем 2 <<наибольшие>>
чередующиеся подпоследовательности $ \alpha_{l_0}\dots\alpha_{l_{k_<}} $ и $ \alpha_{g_0}\dots\alpha_{g_{k_>}} $, такие что $ \alpha_{l_0} < \alpha_{l_1} $
и $ \alpha_{g_0} > \alpha_{g_1} $.
Очевидно, что с помощью полученных из $ V_< $ и $ V_> $ индексов чередующихся подпоследовательностей мы можем
выбрать искомую наибольшую по условию задачи. Если одна из последовательностей длиннее -- очевидно, она наибольшая.
Если же последовательности равны по длинне, то выбирается лексикографически первая, с помощью сравнения номеров 
индексов. Также очевидно, что все номера индексов совпасть не могут, так как тогда элементы по индексам окажутся
одновременно и больше, и меньше друг друга. Следовательно мы восстанавливаем искомую наибольшую чередующуюся
подпоследовательность.



\paragraph{Сложность}
В итоге сложность по времени $ O(n^2) $, алгоритм требует $ O(n) $ дополнительной памяти.




\section{Задача 1-2.} 
\paragraph{Описание алгоритма.}
И так нам задана строка $ \alpha = \alpha_0, \alpha_1, ..., \alpha_n$ состоящяя
из символов алфавита 
$ A = \left\{ 
    \mbox{\footnotesize{`(', `)', `[', `]', `\{', `\}'}}
\right\} $.

Нам следует узнать максимальную длину префикса $ p_{\alpha} = \alpha_0, \alpha_1, ..., \alpha_k \;\;\; k \le n$, такого, что он является
правильной скобочно последовательностью, либо его можно продлить до таковой. Для этого будем использовать стек $ S $,
который поможет нам идентифицировать <<уровень>> скобочности на текущий момент способом
описанным ниже.

Назовем скобку $ c^{-1} $ обратной скобке $ c $, если эти строка $ cc^{-1} $ образует правильную скобочную последовательность.
Заметим, что обратные скобки есть только у открывающихся скобок по определению.

Пройдем по символам строки $ \alpha $ и на каждом следующем символе будем класть, либо доставать элемент из $ S $, а именно:
если встретилась открытая cкобка $ \alpha_i $, делаем $ S.push(\alpha_i^{-1}) $, если встретилась скобка $\alpha_i^{-1}$, сравним ее 
с $ S.pop() $.

Таким образом, каждый раз когда мы проводим операцию $ push $ мы заходим глубже на один уровень во вложенности скобок, в
конце этого уровня мы ожидаем скобку $ c^{-1} $
Очевидно, что как только $ S.pop() $ не будет равняться текущему $ \alpha_i^{-1} $, или $ S $ в момент сравнения окажется пустым, 
то далее последовательность уже не будет правильной и тогда длинна префикса который еще можно продлить до правильной скобочной 
последовательности будет i. (так как символы строки индексировались с 0).

Если мы прошли всю строку и в конце стек оказался пуст. То вместо i следует вывести $ CORRECT $, так как полседовательность оказалась правильной.


\paragraph{Алгоритм по шагам.}
\begin{enumerate}
    \item $i = 0; S = std::stack() $
    \item если $ i \le n $, переходим к следующему шагу, в противном случае к шагу 6
    \item если $ \alpha_i $ открытая скобка, то переходим к шагу 4, в противном случае переходим к шагу 5.
    \item $ S.push(\alpha_i^{-1}) $. Переходим к шагу 2.
    \item если $ S.pop() \ne \alpha_i $, то $ ++i $ переходим к шагу 2, переходим к шагу 6.
    \item если $ i = \alpha.size() \mbox{ and } S.empty() $, вернуть $ CORRECT $, иначе вернуть $ i $.
\end{enumerate}


\paragraph{Доказательство.}
Для начала рассмотрим случай, что алгоритм прошел по всему $ \alpha $ и $ S $ оказался пуст.

То, что каждой открывающейся скобке соответствует закрывающаяся, находящаяся правее ее, скобка следует
из того, что $ S $ пуст. Тогда выбросим из $ \alpha $ все <<тривиальные>> правильные последовательности вида
$cc^{-1}$, получим $ \alpha^{(1)} $. 
Проделаем то же самое с $ \alpha^{1} $... и так далее пока не получим
$ \alpha^{k} $ последовательность без <<тривиальных>> правильных подпоследовательностей. 

Если $ \alpha^{k} $ не пусто, то в определенном месте должна быть неправильная скобочная подпоследовательность из двух символов:
$ c_1c_2 \;\;\;\; c_1^{-1} \ne c_2 $. Но тогда дойдя до $ c_2 $ в $ \alpha \;\;\;\; S.pop() \ne c_2 $, следовательно
алгоритм остановится, последовательность $ \alpha $ пройдена не полностью, что есть противоречие.

В случае когда $ S $ не пуст, очевидно, что либо $ \alpha $ закончилась, либо $ S.pop() \ne \alpha_i $. В первом случае
мы можем легко достроить $ \alpha $ до правильной скобочной последовательности, кладя в нее элементы из $ S $. Во втором,
очевидно, что $ \alpha_0\dots \alpha_i $ не является правильной скобочной последовательностью, зато мы легко можем
достроить $ \alpha_0\dots \alpha_{i-1} $ до правильной описанным выше способом. 


\paragraph{Сложность.}
В итоге сложность по времени $O(n)$. Алгоритм требует $O(n)$ дополнительной памяти.




\section{Задача 1-3.} 
\paragraph{Описание алгоритма.}
Будем говорить, что куб $ A $ меньше чем куб $ B $, или $ A < B $, если для любой стороны $ a $, куба $ A $,
и любой стороны $ b $, куба $ B $, выполнено равенство: $ a < b $.
Очевидно, что $ A $ можно вложить в куб $ B $, тогда и только тогда, когда $ A < B $.

Тогда, строго говоря, входная последовательность кубов не упорядочена по убыванию, так как она упорядочена лишь
по самой короткой стороне кубов. 

Сведем нашу задачу к следующей: Дана входная последовательность кубов $A_0..A_{n-1}$.
Нужно найти длину наибольшей возрастающей подпоследовательности кубов во входной последовательности.

\paragraph{Шаги алгоритма.}
\begin{enumerate}
    \item $ std::vector<Cube> cubes \leftarrow \mbox{ входная последовательность} $ \\
          $ n \leftarrow cubes.size() $ \\
          $ std::vector<size\_t> maxLengthOfLIS \leftarrow std::vector<size\_t>(n, 1)$ \\
          $ i \leftarrow 0 $
    \item Если $ i < n $, то следующий шаг, иначе шаг 7.
    \item $ j \leftarrow 0 $
    \item Если $ j < i $, то следующий шаг, иначе шаг 2.
    \item Если $ cubes[j] < cubes[i] \mbox{   and   } maxLengthOfLIS[j] >= maxLengthOfLIS[i] $, тогда ++$ maxLengthOfLIS[i] $.
    \item ++$j$, переходим к шагу 4.
    \item Выводим на экран $ maxLengthOfLIS[n - 1] $.
\end{enumerate}


\paragraph{Доказательство.}
Допустим, что можно найти максимальную последовательность вложенных кубов $ A_{i_0} \dots A_{i_{k-1}} $, такую, что она больше
чем максимальная возрастающая подпоследовательность $ A_{j_0} \dots A_{j_{ans - 1}} $ входной последовательности кубов.
То есть $ ans < k $.

Так как кубы $ A_{i_0} \dots A_{i_{k-1}} $ вложены друг в друга, то $ A_{i_0} < A_{i_1} < \dots < A_{i_{k-1}} $. Стоит также
заметить, что так как кубы упорядочены по возрастанию, то их самые короткие стороны тоже упорядочены по возрастанию.
Из этого следует, что во входной последовательности кубы $ A_{i_0} \dots A_{i_{k-1}} $ тоже упорядочены по возрастанию, то
есть $ i_0 < i_1 < \dots < i_{k-1} $. Отсюда следует, что последовательность $ A_{i_0} \dots A_{i_{k-1}} $ является вложенной
подпоследовательностью входной последовательности кубов. Селодовательно $ ans \ge k $ -- противоречее.


\paragraph{Сложность.}
В итоге сложность по времени $ O(n^2) $, алгоритм требует $ O(n) $ дополнительной памяти.




\section{Задача 1-4.} 
\paragraph{Описание алгоритма.}
Заведем очередь $ Q $ с поддержкой максимума. В начале инициализируем ее 1-ым элементом входной последовательности, 
теперь когда нам будет встречаться управляющий символ $ R $, будем перемещать правый
итератор и класть число под ним в очередь $ Q $. Если же встечается символ $ L $, будем извлекать 
элемент из очереди $ Q $.

Поддерживать максимум в очереди будем схожим образом с поддержкой минимума в очереди, а именно заведем 2 стека с 
поддержкой максимума. Стоит лишь сказать, что нам не нужны элементы очереди(они и так есть между L и R), 
а нужны только максимумы, которые будут в двух стеках $ S_1 $ и $ S_2 $. 


\paragraph{Алгоритм по шагам}
\begin{enumerate}
    \item $ std::vector<int> \;\;\; data \leftarrow $ входная последовательность \\
          $ std::vector<int>::iterator \;\;\; rightIterator = data.begin() $ \\
          $ std::vector<int>::iterator \;\;\; leftIterator = data.begin() $ \\
          $ std::stack<int> \;\;\; S_1, S_2 $ \\
          $ S_1.push(data[0]) $
    \item $ command \leftarrow $ символ управляющей последовательности из входного потока.
          Если читать нечего, то переходим к шагу 7.
    \item Если $ command = R $, то   ++$rightIterator $ и переходим к шагу 4, иначе ++$leftIterator$ и переходим к шагу 5.
    \item $ S_1.push(\max(S_1.top(), *rightIterator)) $, выводим $ \max(S_1.top(), S_2.top()) $, переходим к шагу 2.
    \item Если $ ! S_2.empty() $, то $ S_2.pop() $, выводим $ \max(S_1.top(), S_2.top()) $ и переходим к шагу 2,
          в противном случае переходим к шагу 6.
    \item Перекладываем по очереди все элементы из $ S_1 $ в $ S_2 $, также с сохранением максимума, переходим к шагу 5.
    \item Конец.
\end{enumerate}


\paragraph{Доказательство.}
По построению верно.


\paragraph{Сложность.}
В итоге сложность по времени $ O(n) $, алгоритм требует $ O(n) $ дополнительной памяти.

\end{document}
