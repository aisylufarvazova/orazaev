\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
\newcommand{\LCS}{\operatorname{LCS}}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm 
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 2-1.}
\paragraph{Описание алгоритма.}
Прибегнем к помощи методов динамического программирования для решения задачи.

У нас есть две входные последовательности $ x = x_0 \dots x_{n - 1} $ и
$ y = y_0 \dots y_{m - 1} $. Заведем массив $ L $ размера $ n + 1 $ на
$ m + 1 $. В $ L[i][j] $ будем хранить длину наибольшей общей 
подпоследовательности($ \LCS $) для перфикса $ x $ длины $ i $ и для префикса $ y $
длины $ j $. Таким образом искомая длина будет храниться в $ L[n][m] $.

\paragraph{Шаги алгоритма.}
\begin{enumerate}
    \item Инициализируем наш массив $ L $ нулями. $ L \leftarrow \{0\} $.

    \item $ L[0][i] $, для $ 0 \le i \le m $ и $ L[i][0] $, для $ 0 \le i \le n $ 
    уже выставлены верно. Так как $ \LCS $ любой
    последовательности с последовательностью длины 0, имеет длину 0.

    \item Посчитаем длинну $ \LCS $ для префикса $ x $
    длины $ i $ и строки $ y $. Для этого инициализируем счетчик цикла 
    $ i \leftarrow 1 $, пока $ i \le n $ делаем:
    \begin{enumerate}
        \item Посчитаем длину $ \LCS $ префикса для 
        $ y $ длины $ j $ и префикса $ x $ длины $ i $. Для этого инициализируем
        счетчик цикла $ j \leftarrow 1 $, пока $ j \le m $ делаем:
        \begin{enumerate}
            \item Полагаем 
            $$ L[i][j] = \left\{ 
                \begin{array}{ll}
                    L[i - 1][j - 1] + 1 &\mbox{, } x_i = y_j \\
                    \max(L[i][j - 1], L[i - 1][j]) &\mbox{, } x_i \ne y_j
                \end{array}
            \right.$$
        \end{enumerate}
    \end{enumerate}

    \item В итоге $ L[n][m] $ длина $ \LCS $ входных
    входных последовательностей $ x $ и $ y $.
\end{enumerate}


\paragraph{Доказательство.}
Наш алгоритм базируются на двух основных утверждениях:
\begin{enumerate}
    \item Если $ x_i = y_j $, то длина $$ \LCS(x_0 \dots x_i, y_0 \dots y_j) = 
    \LCS(x_0 \dots x_{i - 1}, y_0 \dots y_{j - 1}) $$
    
    \item Если $ x_i \ne y_j $, то длина $$ \LCS(x_0 \dots x_i, y_0 \dots y_j) =
    \max(\LCS(x_0 \dots x_{i - 1}, y_0 \dots y_j), \LCS(x_0 \dots x_i, y_0
    \dots y_{j - 1})) $$
\end{enumerate}

Первое утверждение верно, так как мы можем присоеденить к 
$ \LCS(x_0 \dots x_{i - 1}, y_0 \dots y_{j - 1}) $ один дополнительный элемент
$ x_i $ равный $ y_j $.

Второе утверждение верно, так как если $ x_i \ne y_j $, то оба этих символа
одновременно входить в LCS не могут, значит $ \LCS(x_0 \dots x_i, y_0 \dots y_j)$
равен либо $ \LCS(x_0 \dots x_i, y_0 \dots y_{j - 1}) $, либо
$ \LCS(x_0 \dots x_{i - 1}, y_0 \dots y_j) $. Естесственно он равен более длинной
$ \LCS $ из этих двух, а значит в качестве длинны мы можем взять максимум.

Таким образом зная, что для любой строки $ s $ $ \LCS(s, \varnothing) = 0 $.
Мы с помощью доказанных выше утверждений можем получить длину $ \LCS(s, t) $ 
для любой строки $ t $, просто добавляя по одному символу из $ t $: сначала 
$ \LCS(s, t_0) $, затем $ \LCS(s, t_0t_1) $ и так далее до $ \LCS(s, t) $,
попутно вычисляя соответствующие столбцы <<сверху вниз>>(или строки <<слева на 
право >> в точности до перестановки местами аргументов) в L.

В итоге длина $ LCS(s , t) $ окажется равной $ L[s.size(), t.size()] $.

\paragraph{Сложность}
В итоге сложность по времени $ O(n \cdot m) $, алгоритм требует $ O(n \cdot m) $ дополнительной памяти.


\end{document}
