\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm 
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 2-1.}
\paragraph{Описание алгоритма.}
Прибегнем к помощи методов динамического программирования для решения задачи.

У нас есть две входные последовательности $ x = x_0 \dots x_{n - 1} $ и
$ y = y_0 \dots y_{m - 1} $. Заведем массив $ Len $ размера $ n + 1 $ на
$ m + 1 $. В $ Len[i][j] $ будем хранить длину наибольшей общей 
подпоследовательности для перфикса $ x $ длины $ i $ и для префикса $ y $
длины $ j $. Таким образом искомая длина будет храниться в $ Len[n][m] $.

\paragraph{Шаги алгоритма.}
\begin{enumerate}
    \item Инициализируем наш массив $ L $ нулями. $ L \leftarrow \{0\} $.

    \item $ L[0][i] $, для $ 0 \le i \le m $ и $ L[i][0] $, для $ 0 \le i \le n $ 
    уже выставлены верно. Так как наибольшая общая подпоследовательность любой
    последовательности с последовательностью длины 0, имеет длину 0.

    \item Посчитаем длинну наибольшей общей подпоследовательности для префикса $ x $
    длины $ i $ и строки $ y $. Для этого инициализируем счетчик цикла 
    $ i \leftarrow 1 $, пока $ i \le n $ делаем:
    \begin{enumerate}
        \item Посчитаем длину наибольшей общей подпоследовательности префикса для 
        $ y $ длины $ j $ и префикса $ x $ длины $ i $. Для этого инициализируем
        счетчик цикла $ j \leftarrow 1 $, пока $ j \le m $ делаем:
        \begin{enumerate}
            \item Полагаем 
            $$ L[i][j] = \left\{ 
                \begin{array}{ll}
                    L[i - 1][j - 1] + 1 &\mbox{, } x_i = y_j \\
                    \max(L[i][j - 1], L[i - 1][j]) &\mbox{, } x_i \ne y_j
                \end{array}
            \right.$$
        \end{enumerate}
    \end{enumerate}

    \item В итоге $ L[n][m] $ длина наибольшей общей подпоследовательности входных
    входных последовательностей $ x $ и $ y $.
\end{enumerate}


\paragraph{Доказательство.}
Зафиксируем $ y $, докажем по индукции от числа элементов в $ x $, что длина
наибольшей общей подпоследовательности для $ x $ и $ y $ находится правильно.

Для $ x $ длины 0 все, очевидно, верно. Предположим, что для $ x $ длины $ n $
все тоже верно. Рассмотрим случай, когда длина $ x $ будет равна $ n + 1 $.


% Прибегнем к помощи методов динамического программирования для решения задачи.
% 
% У нас есть последовательность $ \alpha = \alpha_0\alpha_1\dots\alpha_{n-1} $.
% Чередующаяся подпоследовательность $ \alpha_{x_0}\alpha_{x_1}...\alpha_{x_k} $ 
% может быть 2-х видов: такая, что $ \alpha_{x_0} < \alpha_{x_1} $, а также такая, что
% $ \alpha_{x_0} > \alpha_{x_1} $.  Заведем 2 вектора: $ V_< $ и $ V_> $, соответственно 
% для каждого из видов возможных чередующихся подпоследовательностей.
% 
% В каждом будем хранить кортежи из 2-х элементов $(l, p)$, где $ V[i].l $ -- 
% длина максимальной чередующейся подпоследовательности заканчивающейся в $ \alpha_i $, 
% а $ V[i].p $ -- позиция предыдущего элемента для $ \alpha_i $ в максимальной 
% чередующейся подпоследовательности, которая заканчивается в $ \alpha_i $.
% 
% Инициализируем $ V[i].l = 1, \;\;\; V[i].p = \NA $ для каждого элемента входной 
% последовательности $ \alpha $, для обеих векторов $ V_< $ и $ V_> $.
% Пробежим по элементам $ \alpha $, от первого до последнего, для каждого элемента
% $ \alpha_i $ найдем значения $ V_<[i], \;\;\; V_>[i] $. Для этого пробежим по
% элементам от $ \alpha_0 $ до $ \alpha_{i-1} $ и для $ V_< $ выберем самый левый элемент,
% такой что:
% $$ 
%     \max\limits_{\tiny\begin{array}{c} j \in [0; i - 1] \\ \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{V_<[j].p}) \\ \alpha_i \ne \alpha_j \end{array} } (V_<[j].l)
% $$
% Здесь $ \sgn $ -- это сигнумю. Позицию $ j $ найденного элемента запишем в 
% $ V_<[i].p $, а в $ V_<[i].l $ запишем $ V_<[j].l + 1 $, так как длинна 
% чередующейся подпоследовательности увеличилась на 1.
% 
% Те же действия проделаем для $ V_> $. Стоит только заменить, что для наших векторов $ V_> $ и $ V_< $
% условиe $ \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{p[j]}) $ будет изменено в случае когда 
% $ V[j].p = \NA $. А конкретно, для $ V_< $, будет следующее условиe:
% $ \alpha_j < \alpha_i $, а для $ V_> $ соответственно, будет $ \alpha_j > \alpha_i$
% 
% В конце выбераем самые левые максимумы $ i_< = \argmax\limits_{0 \le i < n}(V_<[i].l) $ 
% и $ i_> = \argmax\limits_{0 \le i < n}(V_>[i].l) $. Восстанавливаем индексы подпоследовательностей c
% помощью $ V_>[i_>].p $ и $ V_<[i_<].p $. Далее выбираем длиннейшую или в случае равной длинны
% ту последовательность индексов, которая лексикографически раньше. 
% Переворачиваем, выводим на экран элементы по выбранным индексам.
% 
% 
% \paragraph{Алгоритм по шагам.}
% \begin{enumerate}
%     \item $ n \leftarrow \alpha.size() $ \\
%           $ \NA \leftarrow static\_cast<size\_t> (-1)$ \\
%           $ struct Element { size\_t l; size\_t p; } $ \\
%           $ std::vector<Element> V_< \leftarrow std::vector<Element>(n, (1, \NA)) $\\
%           $ std::vector<Element> V_> \leftarrow std::vector<Element>(n, (1, \NA)) $\\
%           $ i \leftarrow 0 $
%     \item Если $ i < n $, то переходим к следующему шагу, иначе шаг 9.
%     \item $ j \leftarrow 0 $
%     \item Если $ j < i $, то переходим к следующему шагу, иначе шаг 8.
%     \item Если $ V_<[i].l \le V_<[j].l \mbox {    and    } [(V_<[j].p = \NA \mbox{    and   } \alpha_j < \alpha_i) $ \\
%           $\mbox{   or   } (V_<[j].p \ne \NA \mbox{    and   } \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{V_<[j].p})] $, то \\   
%           ++$V_<[i].l$, $\;\; V_<[i].p \leftarrow j $.
%     \item Если $ V_>[i].l \le V_>[j].l \mbox {    and    } [(V_>[j].p = \NA \mbox{    and   } \alpha_j > \alpha_i) $ \\
%           $\mbox{   or   } (V_>[j].p \ne \NA \mbox{    and   } \sgn(\alpha_j - \alpha_i) \ne \sgn(\alpha_j - \alpha_{V_>[j].p})] $, то \\   
%           ++$V_>[i].l$, $\;\; V_>[i].p \leftarrow j $.
% 
%     \item ++$j$, переходим к шагу 4
%     \item ++$i$, переходим к шагу 2.
%     \item Берем самый левый элемент из $ V_< $ c максимальным $ l $, восстанавливаем подпоследовательность с помощью
%           поля $ p $ найденного элемента получаем индексы $ ANS_< $
%     \item Берем самый левый элемент из $ V_> $ c максимальным $ l $, восстанавливаем подпоследовательность с помощью
%           поля $ p $ найденного элемента получаем индексы $ ANS_> $
%     \item Выбераем большую подпоследовательность из $ ANS_< $ и $ ANS_> $, в случае равенства выбираем ту, у которой
%           меньше последний элемент, при равенстве, ту у которой меньше предпоследний элемент и так далее.
%     \item Переворачиваем выбранную подпоследовательность. Выводим на экран.
% \end{enumerate}
% 
% 
% \paragraph{Доказательство.}
% Докажем, что с помощью $ V_< $, мы восстановим наибольшую чередующуюся подпоследовательность, 
% для которой ее первый элемент меньше второго.
% Будем доказывать по индукции от числа элементов во входной последовательности. Для 1, очевидно, верно.
% Предположим, что алгоритм работает верно для входной последовательности $ \alpha_0 \dots \alpha_{n - 1} $,
% докажем, что для $ n + 1 $ он работает также верно.
% $\alpha_n$ присоеденится к какой-либо уже имеющейся последовательности(если только входная последовательность
% не состоит из одинаковых элементов). Если эта последовательность будет длиннее уже имеющейся, то алгоритм
% выберет ее как максимальную. Если будет равна текущей, то алгортм оставит старую по лексикографическому
% признаку. Если присоеденится к меньшей чем максимальная подпоследовательность из $ \alpha_0 \dots \alpha_{n - 1} $,
% то, очевидно, что оставит старую. Таким образом все работает верно для последовательности из $ n + 1 $ чисел.
% 
% Для $ V_> $ можно провести аналогичные рассуждения. Таки образом мы определяем 2 <<наибольшие>>
% чередующиеся подпоследовательности $ \alpha_{l_0}\dots\alpha_{l_{k_<}} $ и $ \alpha_{g_0}\dots\alpha_{g_{k_>}} $, такие что $ \alpha_{l_0} < \alpha_{l_1} $
% и $ \alpha_{g_0} > \alpha_{g_1} $.
% Очевидно, что с помощью полученных из $ V_< $ и $ V_> $ индексов чередующихся подпоследовательностей мы можем
% выбрать искомую наибольшую по условию задачи. Если одна из последовательностей длиннее -- очевидно, она наибольшая.
% Если же последовательности равны по длинне, то выбирается лексикографически первая, с помощью сравнения номеров 
% индексов. Также очевидно, что все номера индексов совпасть не могут, так как тогда элементы по индексам окажутся
% одновременно и больше, и меньше друг друга. Следовательно мы восстанавливаем искомую наибольшую чередующуюся
% подпоследовательность.
% 
% 
% 
% \paragraph{Сложность}
% В итоге сложность по времени $ O(n^2) $, алгоритм требует $ O(n) $ дополнительной памяти.


\end{document}
