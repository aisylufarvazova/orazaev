\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\argm}{\operatorname{arg}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm 
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 1-1.}
\paragraph{Описание алгоритма.}
Прибегнем к помощи методов динамического программирования для решения задачи.

Для каждого элемента $ \alpha_i $ из входной последовательности $ \alpha = \alpha_0 \dots \alpha_{n-1} $
будем хранить 4-ку элементов $(l_<,p_<,l_>,p_>)$:
\begin{description}
    \item[$ l_< $] -- длина наибольшей чередующейся подпоследовательности $ \alpha_{x_0} \dots \alpha_{x_k} \alpha_i$
    входной последовательности $ \alpha $, заканчивающийся в $ \alpha_i $, такой, что $ \alpha_{x_k} < \alpha_i $.

    \item[$ p_< $] -- индекс $ x_k $ предпоследнего элемента в наибольшей чередующейся подпоследовательности
    $ \alpha_{x_0} \dots \alpha_{x_k} \alpha_i$ входной последовательности $ \alpha $,
    заканчивающийся в $ \alpha_i $, такой, что $ \alpha_{x_k} < \alpha_i $.

    \item[$ l_> $] -- длина наибольшей чередующейся подпоследовательности $ \alpha_{x_0} \dots \alpha_{x_k} \alpha_i$
    входной последовательности $ \alpha $, заканчивающийся в $ \alpha_i $, такой, что $ \alpha_{x_k} > \alpha_i $.

    \item[$ p_> $] -- индекс $ x_k $ предпоследнего элемента в наибольшей чередующейся подпоследовательности
    $ \alpha_{x_0} \dots \alpha_{x_k} \alpha_i$ входной последовательности $ \alpha $,
    заканчивающийся в $ \alpha_i $, такой, что $ \alpha_{x_k} > \alpha_i $.
\end{description}

Для этого заведем 4 массива $ L_<,P_<,L_>,P_> $ соответственно.
Теперь у нас есть все для того, чтобы найти наибольшую чередующуюся подпоследовательность.




\paragraph{Алгоритм по шагам}
\begin{enumerate}
    \item Для начала инициализируем массивы $ L_< $ и $ L_> $ значением $ 1 $, а массивы $ P_< $ и $ P_> $
    значениями $ \NA $ (Not available).

    \item Пробежимся по всей входной последовательности $ \alpha $. Для текущего элемента $ \alpha_i $
    найдем значения $ L_<[i],P_<[i],L_>[i],P_>[i] $. 

    \item Для этого пробежимся по всем элементам $ \alpha $ от $ \alpha_0 $ до $ \alpha_{i - 1} $. Для
    текущего элемента $ \alpha_j $ проверим следующие условия:
    \begin{enumerate}
        \item Если $ \alpha_j < \alpha_i $ и $ L_>[j] \ge L_<[i] $, то
        полагаем $ L_<[i] \leftarrow L_>[j] + 1 $, а $ P_<[i] \leftarrow j $.
        
        \item Если $ \alpha_j > \alpha_i $ и $ L_<[j] \ge L_>[i] $, то
        полагаем $ L_>[i] \leftarrow L_<[j] + 1 $, а $ P_>[i] \leftarrow j $.
    \end{enumerate}

    \item Из массивов $ L_< $ и $ L_> $ выберем тот, у которого последний элемент $ n - 1 $ больше,
    и уже из выбранного массива(например, с индексом $ < $) выберем максимум с самым меньшим индексом $ k $.
    Если же $ L_< = L_> $, то это вырожденный случай последовательности имеющий вид 
    $ \lambda \lambda \dots \lambda $ и тут без разницы какой из массивов выбрать.

    \item Восстановим найденную подпоследовательность с помощью массивов $ P_< $ и $ P_> $. Для этого положим
    $ e \leftarrow k$. И определим операцию <<обращение>> для символов $>$ и $<$, такую, что $<^{-i} = <$, если
    i четно, и $<^{-i} = >$, если i нечетно. Также для дальнейшего удобства вычислений положим $ c $ равным
    индексу выбранного массива $ L $ на предыдущем шаге(в случае примера это $ < $).

    \item Полагаем $ Len \leftarrow L_c[e]$, $ i \leftarrow 1 $

    \item Пока $ e \ne \NA $: 
    \begin{enumerate} 
        \item Полагаем $x_{Len - i} \leftarrow \alpha_e $. 

        \item Полагаем $ nowIs \leftarrow c^{e - k} $.

        \item После этого полагаем $ e \leftarrow P_{nowIs}[e] $.

        \item Полагаем $ i \leftarrow i + 1 $.
    \end{enumerate}
    
    \item Искомая подпоследовательность $ x_0 \dots x_{Len - 1} $ найдена.
    
\end{enumerate}




\paragraph{Доказательство.}
Будем доказывать по индукции от числа элементов в $ \alpha $. При 1 элементе, очевидно, все работает
правильно. Допустим, что при $ n $ элементах все также работает правильно. Рассмотрим, что будет когда
к последовательности $ \alpha_0 \dots \alpha_{n - 1} $ добавляется элемент $ \alpha_n $.

Сначала вычисляются:
$$ P_>[n] = \operatorname*{arg\,max}\limits_{ 0 \le i < n;\;\; \alpha_j > \alpha_i} (L_<[i]), $$ 
$$ P_<[n] = \operatorname*{arg\,max}\limits_{ 0 \le i < n;\;\; \alpha_j < \alpha_i} (L_>[i]), $$ 
при этом выбирается самые левые из возможных индексов. А также длины:
$$ L_>[n] = L_<[P_<[n]] + 1, $$
$$ L_<[n] = L_>[P_>[n]] + 1, $$

Допустим, $ \alpha_{x_0} \dots \alpha_{P_>[n]} \alpha_n $ не является наибольшей чередующейся 
подпоследовательностью, такой, что $ \alpha_{P_>[n]} > \alpha_n $. Тогда существует другая 
чередующаяся подпоследовательность $ \alpha_{y_0} \dots \alpha_{y_k} \alpha_n $, такая что
$ \alpha_{y_k} > \alpha_n $, тогда $ L_<[y_k] > L_<[P_>[n]] $, но это противоречит с вычислением
$ P_>[n] $, так как он есть $ \operatorname*{arg\,max}(L_<[i]) $. Или еще возможен случай,
когда $ L_<[y_k] = L_<[P_>[n]] $, но в таком случае $ y_k = P_>[n] $, так как выбирается
самый левый индекс. Таким образом $ \alpha_{x_0} \dots \alpha_{P_>[n]} \alpha_n $ является
наибольшей чередующейся подпоследовательностью, такой, что $ \alpha_{P_>[n]} > \alpha_n $.

Аналогичные рассуждения можно провести для $ P_<[n] $

Таким образом мы знаем предпоследний индекс и длины наибольших чередующеихся подпоследовательностей,
таких, что предпоследний элемент больше $\alpha_n$ и соответственно меньше $\alpha_n$. Из этих данных
легко восстановить наибольшую чередующуюся подпоследовательность $ A_n = \alpha_{x_0} \dots \alpha_{x_k} \alpha_n $
входной последовательности $ \alpha $, заканчивающуюся в $ \alpha_n $.

Далее возможны следующие случаи:
\begin{enumerate}
    \item Длина $ A_n $ будет больше чем $ A_{n - 1} $, в таком случае 
    $ \max(L_<[n], L_>[n]) > \max(L_<[n-1],L_>[n-1]) $. 

    \item Длина $ A_n $ будет равна $ A_{n-1} $, в таком случае $ A_n $
    не будет выбрана наибольшей чередующейся подпоследовательностью по
    лексикографическому признаку и ответ останется старым(таким же как и
    для случая n), верным по индуктивному предположению.
\end{enumerate}

Длина $ A_n $ не может быть меньше $ A_{n - 1} $, так как $ L_<[n] \ge L_<[n - 1] $ и $ L_>[n] \ge L_>[n - 1] $. 
Докажем последнее. Пусть была последовательность $ x_0 \dots x_k < x_{n - 1}$, тогда если $ x_{n - 1} > x_{n} $,
то последовательность увеличится в длинне, а если $ x_{n - 1} < x_n $, то и $ x_k < x_n $, откуда следует, что
длинна последовательности не убывает. Аналогичные рассуждения можно провести и для $ x_k > x_{n - 1} $.

Таким образом все возможные случаи при добавлении $ \alpha_n $ сопутствуют правильному нахождению
наибольшей чередующейся подпоследовательности входной поcледовательности $ \alpha_0 \dots \alpha_n $ длины n + 1.




\paragraph{Сложность}
В итоге сложность по времени $ O(n^2) $, алгоритм требует $ O(n) $ дополнительной памяти.


\end{document}
