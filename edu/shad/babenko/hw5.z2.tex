\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[ruled, lined]{algorithm2e}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
\newcommand{\LCS}{\operatorname{LCS}}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 5-2.}
\paragraph{Описание алгоритма.}
Итак у нас есть изначально $ n $ свободных мест на круговой парковке.
А также последовательность $ Events $ из $ m $ произошедших событий.

Заведем массив $ ParkingPlaces $ типа bool длины $ n $, где каждое $ i - 1 $ ячейка
будет соответствовать свободно или занято место под номером $ i $.

В начальном состоянии весь массив заполнен значениями true: все места
на парковке свободны.

На этом массиве простроим дерево отрезков $ freePlaceTree $ такое, что в
каждой вершине хранится свободное место с минимальным номером на
соответствующем отрезке, в случае отсуствия такового будем хранить в
вершине, скажем, $ -1 $.

Добавим кроме указателей на левого и правого сына, еще и указатель на
предка. В том числе и в листы-ячейки массива. Под левым сыном будем
понимать того, в чьем подотрезке индексы меньше.

Заведем класс $ Parking $, интерфейс которого состоит из двух функций
возвращающих $ int $:
\begin{itemize}
    \item int takeCarPlace(size\_t placeNo)
    \item int leaveCarPlace(size\_t placeNo)
\end{itemize}
Будем вызывать соответсвующий метод в зависимости от события из $ Events $.

Опишим подробнее сами методы:

Функция takeCarPlace возвращает -1 если корень дерева
$ freePlaceTree.Root.minFreePlace == -1 $ пусто, то есть на всей парковке нет
свободного места.
В противном случае мы идем по индексу $ ParkingPlaces[placeNo - 1] $, если там
<<свободно>> занимаем это место с последующим обновлением значений в $ freePlaceTree $,
либо ищем во всех отрезках правее текущего индекса, следующим образом:
\begin{enumerate}
    \item Пока мы не в левом сыне поднимаемся вверх, если это корень и $ minFreePlace == -1$,
          то возвращаем -1, если же $ minFreePlace \ne -1 $, то возвращаем значение
          $ minFreePlace $, в соответствующей ячейке массива выставляем $ isFree := False $
          и обновляем дерево.

    \item В противном случае(мы не в корне), идем в правого брата(вверх-вправо). Если значение
          $ minFreePlace == -1 $, снова шаг 1. Если же значение $ minFreePlace \ne -1 $,
          возвращаем $ minFreePlace $, правим соотвествующую ячейку в массиве $ ParkingPlaces $,
          обновляем $ freePlaceTree $. конец.
\end{enumerate}

Тонкий момент: возможен еще случай, когда мы оказались в левом сыне, но правого брата у него не существует
по причине того, что число свободных мест не есть степень двойки, то есть правый брат $ NULL $.
В таком случае следует подняться в отца найденного левого сына и снова перейти к шагу 1.

Функция leaveCarPlace возвращает -2, если
$ ParkingPlaces[placeNo - 1].isFree == True $, то есть место уже свободно.
В другом случае устанавливаем $ ParkingPlaces[placeNo - 1].isFree := True $,
то есть освобождаем место и идем вверх по дереву отрезков
обновляя значения минимального свободного места на отрезке текущей вершины,
пока не встретим не отрицательное значение с местом меньшим чем $ placeNo $.



\paragraph{Доказательство.}
Обновление дерева отрезков рассматривалось на семинаре тут все идентично
с точностью до поддерживаемого параметра, поэтому доказать пожалуй стоит
правильность описанного поиска следующего свободного места на парковке, или
минимального, если все большие заняты.

Рассмотрим возможные случаи:
\begin{itemize}
    \item Мы находимся не в корне, при этом на отрезке принадлежащем текущей вершине
          нет свободных мест больших $ placeNo $. Если мы в правом сыне, то очевидно,
          следующий отрезок будет охватываться ближайшим <<правым дядей>> текущей вершины,
          так как областью отвественности <<левых дядь>> будут отрезки
          с номерами парковочных мест меньшими чем $ placeNo $, и отец <<предка>>
          и <<дяди>> также будет охватывать места меньшие чем $ placeNo $.
          
          (Важно понимать, что <<дядей>> здесь называется вершина, которая является
          братом предка, а не только отца, текущей вершины).

          Также понятно, что не будет зазора между отрезком найденного <<правого дяди>>
          и текущей вершиной, так как текущая вершина отвечает за самый правый подотрезок
          <<брата правого дяди>>(ближайшего левого предка текущей вершины), а между
          <<правым дядей>> и его братом нет зазора, так что какое либо свободное место в
          отрезке <<отца правого дяди>> мы не пропустим.

          Получается, что следующий отрезок действительно находится под юрисдикцией
          ближайшего существующего <<правого дяди>>.

    \item Если мы в левом сыне, то очевидно ближайший следующий отрезок будет охватываться
          нашим <<правым братом>>, поэтому стоит проверить его и в случае отсутствия
          свободных мест подниматься вверх в поисках <<правого дяди>>. Случай, когда
          правого брата не существует обрабатывается также -- ищем следующего <<правого
          дядю>>, так как отрезки отца и сына совпадут, а в сыне нет искомого свободного
          места.

    \item Мы находимся в корне, в этом случае на всем отрезке мы не нашли
          большего свободного места чем, $ placeNo $, так как область поиска
          следующего большего свободного места должна быть не в этом поддереве, а
          либо в <<братском>>(мы в левом сыне), либо в одном из <<дядь>>(мы в правом сыне).
          У корня ни <<братьев>>, ни <<дядь>>, а следовательно на всем орезке
          нет следующего свободного места, большего чем $ placeNo $. По
          условию задачи мы делаем круг и выбираем минимальное свободное
          место на всем отрезке парковочных мест, а оно либо находися в корне,
          либо его вообще нет (в корне -1).

    \item Если <<правого дяди>> нет, то мы упремся в корень и произойдет ситуация
          описанная выше.
\end{itemize}


% Доказать тут, скорее, стоит то, что правильно поддерживается
% минимальное свободное место в дереве отрезков $ freePlaceTree $.
% 
% Рассмотрим запрос с отъездом машины с места $ placeNo $. Отбросим
% тривиальный случай -- место уже свободно -- тогда следует рассмотреть
% обновление листа $ L $ ($ ParkingPlaces[placeNo - 1] $).
% В листе очевидно выставляется $ placeNo $. Допустим для какого-то предка
% $ F $ листа $ L $ после обновления значение $ minFreePlace $ будет неверным.
% То есть существует свободное место $ P $, меньшее, чем значение $ minFreePlace $
% в $ F $, после обновления. Это невозможно, так как если какое-то
% значение и изменяется, то оно изменяется на $ placeNo $, так как изменяются
% все родители $ L $ в которых $ minFreePlace > placeNo $ (или равные -1), так как мы изменили
% <<свободность>> лишь одного места. Следовательно неверное значение может быть
% лишь $ placeNo $, но у предка до этого $ minFreePlace $ было больше $ placeNo $,
% следовательно минимальное значение на отрезке изменилось на более меньшее(либо на единственное
% в случае -1), действительно свободное $ placeNo $, либо оно не менялось вообще.
% 
% Рассмотрим запрос на приезд машины.
% Поиск места производится верно.


\paragraph{Сложность}
Сложность по времени $ O(m \cdot log(n) + n \cdot log(n)) $.
Первое слагаемое это обработка $ m $ событий, второе слогаемое построение
красно-черного дерева в самом начале.

Алгоритм требует $ O(m) $ дополнительной памяти.

\end{document}
