\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[ruled, lined]{algorithm2e}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
\newcommand{\LCS}{\operatorname{LCS}}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 5-2.}
\paragraph{Описание алгоритма.}
Итак у нас есть изначально $ n $ свободных мест на круговой парковке.
А также последовательность $ Events $ из $ m $ произошедших событий.

Решать задачу будем с помощью дерева отрезков, для этого:
заведем массив $ ParkingPlaces $ длины $ n $ для листов дерева, где
в каждой ячейке будем хранить либо номер в массиве $ + 1 $ (минимальное
свободное место на отрезке длинны 1) в случае если место свободно, либо
специальное значение $ -1 $ в случае если место занято.

Далее уже до конца строим дерево отрезков $ freePlaceTree $ такое, что в
каждой вершине хранится свободное место с минимальным номером на
соответствующем отрезке, в случае отсуствия такового будем хранить в
вершине $ -1 $.

При построении, если отрезок вершины не пересекается с множеством
индексов в массиве $ ParkingPlaces $, $ {0 \dots n-1} $, просто не
строим вершину, а у ее предка(если он существует) выставляем указатель
на неродивого сына в $ NULL $.

В вершинах, в том числе и в листовых, кроме указателей на правого и
левого сына будем хранить еще и указатель на отца, а также определим
тривиальные функции для вершин:
\begin{itemize}
    \item bool isFree() -- есть ли свободное место на отрезке.
    \item int getMinFreePlace() -- вернуть свободное место с наименьшим
          номером, либо вернуть -1, если свободных мест нет.
    \item void setMinFreePlace(int newMinPlace) -- обновить значение места
          с минимальным номером на отрезке вершины.
\end{itemize}

Под левым сыном будем понимать того, в чей подотрезок находится левее,
то есть номера мест на отрезке левого сына меньше.

Заведем класс $ Parking $, интерфейс которого состоит из двух функций
возвращающих $ int $:
\begin{itemize}
    \item int takeCarPlace(size\_t placeNo)
    \item int leaveCarPlace(size\_t placeNo)
\end{itemize}
Будем вызывать соответсвующий метод в зависимости от события из $ Events $.

Опишим подробнее сами методы:

Функция takeCarPlace возвращает -1 если корень дерева занят
$ !freePlaceTree.root.isFree() $, то есть на всей парковке нет
свободного места. В противном случае мы идем к листу
$ ParkingPlaces[placeNo - 1] $, если там <<свободно>> занимаем это место с
последующим обновлением значений в $ freePlaceTree $,
либо ищем во всех отрезках правее текущего листа в массиве $ ParkingPlaces $
следующим образом:
\begin{enumerate}
    \item Пока мы не в левом сыне поднимаемся вверх, если уперлись в корень
          и $ !isFree() $, то возвращаем -1, если же $ isFree() $, то
          возвращаем значение $ place = getMinFreePlace() $, в
          соответствующем листе массива $ L = ParkingPlaces[place - 1] $
          выставляем $ L.setMinFreePlace(-1) $ и обновляем дерево.

    \item В противном случае(мы не в корне), идем в правого брата
          (вверх-вправо) $ B $. Если $ !B.isFree() $ или правого брата нет
          поднимаемся дальше -- шаг 1.
          Если же значение $ B.isFree() $, возвращаем $ getMinFreePlace $,
          правим лист в массиве $ L = ParkingPlaces[B.getMinFreePlace() - 1] $,
          обновляем $ freePlaceTree $. конец.
\end{enumerate}



Функция leaveCarPlace возвращает -2, если
$ ParkingPlaces[placeNo - 1].isFree() == True $, то есть место уже свободно.
В другом случае устанавливаем
$ ParkingPlaces[placeNo - 1].setMinFreePlace(-1)$, то есть освобождаем
место и идем вверх по дереву отрезков обновляя значения минимального
свободного места на отрезке текущей вершины, пока не встретим в
$ getMinFreePlace() $ не отрицательное значение с местом меньшим
чем $ placeNo $.



\paragraph{Доказательство.}
Обновление дерева отрезков рассматривалось на семинаре тут все идентично
с точностью до поддерживаемого параметра, поэтому доказать пожалуй стоит
правильность описанного поиска следующего свободного места на парковке, или
минимального, если все большие заняты.

Рассмотрим возможные случаи:
\begin{itemize}
    \item Мы находимся не в корне, при этом на отрезке принадлежащем текущей вершине
          нет свободных мест больших $ placeNo $. Если мы в правом сыне, то очевидно,
          следующий отрезок будет охватываться ближайшим <<правым дядей>> текущей вершины,
          так как областью отвественности <<левых дядь>> будут отрезки
          с номерами парковочных мест меньшими чем $ placeNo $, и отец <<предка>>
          и <<дяди>> также будет охватывать места меньшие чем $ placeNo $.

          (Важно понимать, что <<дядей>> здесь называется вершина, которая является
          братом предка, а не только отца, текущей вершины).

          Также понятно, что не будет зазора между отрезком найденного <<правого дяди>>
          и текущей вершиной, так как текущая вершина отвечает за самый правый подотрезок
          <<брата правого дяди>>(ближайшего левого предка текущей вершины), а между
          <<правым дядей>> и его братом нет зазора, так что какое либо свободное место в
          отрезке <<отца правого дяди>> мы не пропустим.

          Получается, что следующий отрезок действительно находится под юрисдикцией
          ближайшего существующего <<правого дяди>>.

    \item Если мы в левом сыне, то очевидно ближайший следующий отрезок будет охватываться
          нашим <<правым братом>>, поэтому стоит проверить его и в случае отсутствия
          свободных мест подниматься вверх в поисках <<правого дяди>>. Случай, когда
          правого брата не существует обрабатывается также -- ищем следующего <<правого
          дядю>>, так как отрезки отца и сына совпадут, а в сыне нет искомого свободного
          места.

    \item Мы находимся в корне, в этом случае на всем отрезке мы не нашли
          большего свободного места чем, $ placeNo $, так как область поиска
          следующего большего свободного места должна быть не в этом поддереве, а
          либо в <<братском>>(мы в левом сыне), либо в одном из <<дядь>>(мы в правом сыне).
          У корня ни <<братьев>>, ни <<дядь>>, а следовательно на всем орезке
          нет следующего свободного места, большего чем $ placeNo $. По
          условию задачи мы делаем круг и выбираем минимальное свободное
          место на всем отрезке парковочных мест, а оно либо находися в корне,
          либо его вообще нет (в корне -1).

    \item Если <<правого дяди>> нет, то мы упремся в корень и произойдет ситуация
          описанная выше.
\end{itemize}


% Доказать тут, скорее, стоит то, что правильно поддерживается
% минимальное свободное место в дереве отрезков $ freePlaceTree $.
%
% Рассмотрим запрос с отъездом машины с места $ placeNo $. Отбросим
% тривиальный случай -- место уже свободно -- тогда следует рассмотреть
% обновление листа $ L $ ($ ParkingPlaces[placeNo - 1] $).
% В листе очевидно выставляется $ placeNo $. Допустим для какого-то предка
% $ F $ листа $ L $ после обновления значение $ getMinFreePlace $ будет неверным.
% То есть существует свободное место $ P $, меньшее, чем значение $ getMinFreePlace $
% в $ F $, после обновления. Это невозможно, так как если какое-то
% значение и изменяется, то оно изменяется на $ placeNo $, так как изменяются
% все родители $ L $ в которых $ getMinFreePlace > placeNo $ (или равные -1), так как мы изменили
% <<свободность>> лишь одного места. Следовательно неверное значение может быть
% лишь $ placeNo $, но у предка до этого $ getMinFreePlace $ было больше $ placeNo $,
% следовательно минимальное значение на отрезке изменилось на более меньшее(либо на единственное
% в случае -1), действительно свободное $ placeNo $, либо оно не менялось вообще.
%
% Рассмотрим запрос на приезд машины.
% Поиск места производится верно.


\paragraph{Сложность}

В итоге высота дерева $ H = \lceil log_2(n) \rceil $. Значит сложность
операций в худшем случае $ O(H) $. Построение дерева можно сделать за
$ O(n) $, так как минимальные свободные места находятся тривиально.
Итого сложность по времени $ O(m \cdot \lceil log_2(n) \rceil + n) $.

Алгоритм требует $ O(n) $ дополнительной памяти. Это только на дерево,
если не хранить события, а обрабатывать из потока ввода.

\end{document}
