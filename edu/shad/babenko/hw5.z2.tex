\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[ruled, lined]{algorithm2e}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
\newcommand{\LCS}{\operatorname{LCS}}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 5-2.}
\paragraph{Описание алгоритма.}
Итак у нас есть изначально $ n $ свободных мест на круговой парковке.
А также последовательность $ Events $ из $ m $ произошедших событий.

В начале алгоритма построим красно черное дерево freePlaceTree свободных
мест на парковке (ключ -- номер места). Это займет у нас $ O(n \cdot log(n)) $
по времени.

Заведем класс $ Parking $, интерфейс которого состоит из двух функций
возвращающих $ int $:
\begin{itemize}
    \item int takeCarPlace(size\_t placeNo)
    \item int leaveCarPlace(size\_t placeNo)
\end{itemize}
Будем вызывать соответсвующий метод в зависимости от события из $ Events $.

Опишим подробнее сами методы:

Функция takeCarPlace возвращает -1 если дерево $ freePlaceTree $ пусто.
В противном случае ищет вершину с минимальным ключем $place \le placeNo$,
если все ключи дерева оказались меньше placeNo, то выбирает вершину с
минимальным ключем (машина сделала круг на парковке).
Далее выбранная вершина удаляется, а ее ключ возвращается из функции.

Функция leaveCarPlace возвращает -2, если в дереве $ freePlaceTree $ есть
вершина с ключем $ placeNo $. В противном случае добавляет новую вершину
с ключем $ placeNo $ и возвращает 0.

Из необычных операций с деревом есть только $ findEqualOrGreater(placeNo) $:
найти вeршину с минимальным ключем меньшим либо равным $ placeNo $. Опишем
эту операцию подробнее:
\begin{enumerate}
    \item Ищем в дереве ключ $ placeNo $ как обычно, если находим, то
          возвращаем вершину.
    \item Если вершина не найдена, то мы попадаем в лист дерева, далее
          ищем следующий по возрастанию ключ в дереве относительно листа.
    \item Пока не окажемся левым сыном идем вверх по дереву, если невозможно
          возвращаем 0.
    \item Поднимаемся еще на один уровень вверх (мы это можем, так как мы
          чей-то левый сын).
    \item Вовзращаем текущую вершину.
\end{enumerate}

В остальном из операций с деревом используются стандартные $ insert $,
$ delete $, $ find $. Ну и менее стандартный $ min $ -- самая левая
вершина дерева.

\begin{function}
    \KwIn{Место, которое хочет занять машина}
    \KwOut{Номер занятого места или -1, если места не нашлось}
    \SetKwData{FPT}{freePlaceTree}
    \SetKwData{PlaceNo}{placeNo}
    \SetKwData{Node}{node}
    \SetKwData{Ans}{ans}
    \Begin{
        \If {\FPT is empty} {
            \Return{-1}\;
        }

        Node* \Node = \FPT.findEqualOrGreater(\PlaceNo)\;
        \If {\Node == 0} {
            \Node = \FPT.min()\;
        }

        \Ans = \Node$\rightarrow$getKey()\;
        \FPT.delete(\Node)\;
        \Return{\Ans}\;
    }
    \caption{int takeCarPlace(size\_t placeNo)}
    \label{algo:duplicate2}
\end{function}

\begin{function}
    \dontprintsemicolon
    \KwIn{Место, c которого машина уезжает}
    \KwOut{0 если машина на месте была, -2 если место было свободно}
    \SetKwData{FPT}{freePlaceTree}
    \SetKwData{PlaceNo}{placeNo}
    \SetKwData{Node}{node}
    \Begin{
        Node* \Node = \FPT.find(\PlaceNo)\;

        \If {node $\ne$ 0} {
            \Return{-2}\;
        }

        \FPT.insert(\PlaceNo)\;
        \Return{0}\;
    }
    \caption{int leaveCarPlace(size\_t placeNo)}
    \label{algo:duplicate2}
\end{function}


\paragraph{Доказательство.}
В случае правильной работы красно-черного дерева, очевидно, что будет
правильно поддерживаться инвариантность свободных мест на парковке и
дерева свободных мест, то есть мы верим, что добавления (в случае отъезда
машины) и удаление (в случае приезда) работают правильно.

Доказать тут, наверное, следует только то, что $ findEqualOrGreater(placeNo) $
работает правильно.

Рассмотрим возможные случаи:
\begin{itemize}
    \item Мы с помощью обычного бинарного поиска нашли вершину $ N $,
          такую, что $ N.key = placeNo $:

          Тут очевидно, что $ N.key $ минимальный ключ из возможных
          ключей дерева, таких что $ key >= placeNo $. Верно.

    \item Ключ не найден, то есть мы уперлись в нулевой указатель
          во время бинарного поиска.
          Пока мы не окажемся в левом сыне поднимаемся вверх, но
          оказались в корне так и не оказавшись левым сыном.

          Так как мы в дереве, то отсюда следует, что путь от листа
          с которого мы поднимались до корня один, и если мы не разу
          не оказались в левом сыне, то от корня мы постоянно спускались
          вправо. Отсюда следует, что $ placeNo $ больше любого ключа
          из дерева. Селдовательно искомой вершины нет, возвращаем 0.

    \item Ключ не найден, то есть мы уперлись в нулевой указатель
          во время бинарного поиска.
          Поднялись вверх до момента, когда стали левым сыном, если
          сразу не были левым, конечно. Далее еще раз поднялись в вершину
          $ F $. И вернули ее.

          Фактически мы знаем, что искомый ключ лежит в поддереве
          $ F $ всего исследуемого дерева, так как если $ F $ корень, то
          это верно, а если $ F $ не корень, то по свойствам дерева
          поиска все оставшиеся вершины либо строго больше(если $ F $
          левый сын), либо строго меньше $ placeNo $ (если F правый сын).

          Чуть подробнее:
          Мы знаем, что $ placeNo $ меньше чем $ F $, нас не интересуют
          вершины не принадлежащие поддереву порождаемому из $ F $,
          когда $ F $ правый сын, так как все эти вершины строго меньше
          $ placeNo $, а мы ищем большие либо равные.
          Также нас не интересуют вершины не принадлежащие поддереву
          порождаемому из $ F $, когда $ F $ левый сын, так как ключ
          $ F $ строго меньше любого из ключей этих вершин, но при этом
          $ F $ больше чем $ placeNo $, значит ответ либо $ F $, либо
          в поддеревьях $ F $(левом или правом).

          Искомая вершина не может находится в левом поддереве $ F $, так
          как $ placeNo $ больше любого ключа из этого поддерева.
          Искомая вершина не может находится в правом поддереве $ F $, так
          как все вершины этого поддерева по ключу больше чем $ F $, а
          $ placeNo < F.key $, отсюда следует, что все правое поддерево
          можно отбросить.

          И остается один единственный возможный ответ $ F $.
\end{itemize}

\paragraph{Сложность}
Сложность по времени $ O(m \cdot log(n) + n \cdot log(n)) $.
Первое слагаемое это обработка $ m $ событий, второе слогаемое построение
красно-черного дерева в самом начале.

Алгоритм требует $ O(m) $ дополнительной памяти.

\end{document}
