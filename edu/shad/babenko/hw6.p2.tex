\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[ruled, lined]{algorithm2e}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
\newcommand{\LCS}{\operatorname{LCS}}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 6-2.}
\paragraph{Описание алгоритма.}
Итак у нас есть $ n $ секретных агентов, каждый со своими координатами
$ x $, $ y $.

Нужно найти минимальное $ R $ -- радиус действия рации -- чтобы любой
агент $ A $ мог передать сообщение агенту $ B $.

Другими словами у нас есть граф $ G $ вершинами которого являются наши
агенты. А ребрами соединены агенты, которые могут связаться между собой
по рации. Причем веса ребер это рассотяние между агентами.

В такой интерпретации нам нужно из графа $ G $ получить связанный граф,
путем пририсовывания ребер, так, чтобы максимальный вес из всех ребер
был минимальным из возможных. То есть мы минимизируем вес самого тяжолого
ребра для всех возможный связанных графов $ G $ c фиксированными вершинами
<<агентами>>.


Для этой задачи будем использовать две структуры данных: кучу и DSU (система
непересекающихся множеств).

Определим ребрo $ Edge $ как структуру хранящую:
\begin{itemize}
    \item $ Agents $ 2-x агентов, которых ребро соединяет
    \item $ Weight $ вес ребра, расстояние между агентами.
\end{itemize}


В начале заполним кучу $ EdgeHeap $ всеми возможными ребрами,
причем приоритетами выберем вес ребра $ Weight $.

Заведем DSU для всех агентов $ AgentsDSU $, кроме всего прочего
будем хранить в нем еще и число компонент связаности.

Далее выполняем следующие действие пока число компонент связности
в $ AgentsDSU $ больше 1.
\begin{enumerate}
    \item Берем ребро $ E $ из $ EdgeHeap $
    \item Добавляем его в граф $ AgentsDSU.Union(E.Agents[0], E.Agents[1]) $.
\end{enumerate}

Вес последнего ребра связавшего граф и будет ответом.




\paragraph{Доказательство.}
Утвержается, что подобранный инвариант с графом уместен.
Если нарисовать всех агентов на плоскости, и руками
прорисовывая связи между агентами меньшие либо равные чем искомое $ R $,
то получится граф, у которого самое длинное ребро будет $ R $.

И в обратную сторону, если есть связный граф с минимизированным
максимальным весом ребра $ R $, то каждую вершину графа мы можем
назвать агентом с координатами вершины, при этом каждый агент сможет
связаться по рации мощности $ R $ так как расстояние между агентами
меньше либо равно $ R $ и <<по цепочке>> агенты смогут связываться.

Меньше чем $ R $ в обоих случаях выбрать не получится, так как
если выкинуть ребро с весом $ R $ из графа -- он становится не связным.

Также oчевидно, что получившийся жадный алгоритм добавления ребер решает задачу.
Так как если существует более легкое ребро $ E1 $, которое <<связывает>> граф
(то есть если пририсовать к графу все возможные ребра легче $ E1 $ он станет
связаным), то оно равняется нашему последнему выброшеному из кучи ребру $ E $,
так как мы перебрали все ребра легче $ E $ по свойству кучи и граф еще не был
связан, что гарантирует число компонент связности в DSU большее чем 1.




\paragraph{Сложность}
Самая трудоемкая операция это построение кучи, которое будет работать
за $ O(n^2 \cdot log(n)) $, далее DSU работающее за итерированный логарифм
на операцию своей копейки в общую сложность не внесет.

Итого сложность по времени $ O(n^2 \cdot log(n)) $.

Алгоритм требует $ O(n^2) $ дополнительной памяти.

\end{document}
