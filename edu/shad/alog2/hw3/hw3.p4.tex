\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[ruled, lined]{algorithm2e}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
\newcommand{\LCS}{\operatorname{LCS}}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 3-4.}
\paragraph{Описание алгоритма.}
Для решения задачи несколько модифицируем алгорит Укконена для построения
суффиксных деревьев.

В каждой вершине $ v $ суффиксного дерева будем хранить также $ L_{v} $
длину префикса определяемого текущей вершиной для своего суффикса. Простыми
словами: глубину графа выраженную в символах, а не в вершинах.

Введем следующую модификацию в алгоритм: каждый раз, добавляя новую не
листовую вершину в дерево будем заполнять соответствующее поле массива
$ l $, с результатами работы алгоритма. Делать это будем вот так.

Перед началом алгоритма построения суффиксного дерева заполним весь массив
$ l $ нулями.

Пусть на шаге $ i + 1 $ нам встретился символ $ T[i + 1] = x $ и на
этом шаге нам стоит добавить вершину $ v $ в дерево. Заметим,
что у нас уже есть построенное суффиксное дерево $ ST_i $, которое выглядит
следующим образом.
\begin{center}
    \includegraphics[width=60bp]{before_addition.png}
\end{center}

После добавления не листовой вершины дерево изменится следующим образом:
\begin{center}
    \includegraphics[width=100bp]{after_addition.png}
\end{center}

Здесь $ \alpha $ может быть не просто дугой, а путем из нескольких дуг до
вершины $ v $. В

Далее мы пологаем $ l_{i - |\alpha| + 1} = |\alpha| $, где $ |\alpha| = L_v $.
То есть отмечаем, что в позиции $ j = i - |\alpha| + 1 $,  $ \alpha $ --
наибольшая по длинне подстрока входного текста $ T $, начинающаяся в
позиции $ j $, которая также ранее встречается в $ T $.

Утверждается, что алгоритм Укконена с введенной модификацией вычисляет
искомый массив $ l $, для текста $ T $. С поправкой на то, что в конец
текста надо добавить сэнтинел $\$$.


\paragraph{Доказательство.}
Утверждение 1. При добавлении не листовой вершины $ v $ на шаге $ i + 1 $
описанного выше модифицированного алгоритма Укконена, $ L_v $ является
наибольшей длинной подстроки входного текста $ T $, короторая начинается в
позиции $ j = i - L_v + 1 $, а также ранее встречается в $ T $.

Допустим $ \alpha = T[j:i] $. Очевидно, что $ L_v > 0 $, так как мы
добавляем нелистовую вершину в суффиксное дерево, а также что на пути
от корня до вершины $ v $ "лежит" строка $ \alpha $.

Пусть существует $ l_j^1 > L_v $, для которого существует $ j^1 < j $
$ T[j^1:j^1 + l_j^1 - 1] = T[j:j + l_j^1 - 1] $. Иными словами $ l_j $
мы должны положить равным $ l_j^1 $, а не $ L_v $. В таком случае
должна существовать строка $ \beta = T[j:j + l_j^1 - 1$, которая уже
находится в суффиксном дереве полученном на шаге $ i $, так как она
встречалась ранее в тексте $ T $.
Но на шаге $ i + 1 $ мы добавляем не листовую вершину $ v $ в дерево, а
значит, строки $ \beta $ на шаге $ i $ в дереве не было. Противоречие.

Утверждение 2.



Доказательство приведено во 2-ой лекции.






\paragraph{Сложность}
% FIXME: write complexity
Сложность по времений $ O(N) $.
Сложность по памяти $ O(N) $.

\end{document}
