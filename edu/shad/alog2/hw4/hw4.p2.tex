\documentclass[12pt]{article}

\usepackage{amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[ruled, lined]{algorithm2e}

\textheight=220mm
\textwidth=160mm

\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\NA}{\operatorname{NA}}
\newcommand{\OR}{\operatorname{ or }}
\newcommand{\LCS}{\operatorname{LCS}}
%\DeclareMathOperator{\sgn}{sgn}

\title{\bf Домашнее задание по курсу \\ <<Методы
и структуры данных поиска.>>}
\author{А.Е. Оразаев}
\date{}
\begin{document}

\voffset=-20mm
\hoffset=-12mm
\font\Got=eufm10 scaled\magstep2 \font\Got=eufm10

\maketitle

\section{Задача 4-2.}
\subsection{Описание алгоритма.}

Нам дано:
\begin{itemize}
    \item Число правил вывода $ |R| $.
    \item Контекстно-свободная грамматика $ G = \{N, \Sigma, R, S\} $.
    \item Наибольшая длина строки $ k $.
\end{itemize}

Нужно найти наименьшую строку $ \alpha_{\min} $ принадлежащую грамматике
$ G $, такую что $ |\alpha_{\min}| \le k $

План следующий: опишем алгоритм, докажем его, введем несколько шагов
препроцессинга оптимизирующих время работы, покажем, что введенные
оптимизации обоснованы.

Здесь и далее под наименьшей строкой мы будем понимать наименьшую
лексикографически строку.

Для решения задачи введем несколько понятий:
\begin{itemize}
    \item Простым правилом, или простой продукцией будем называть продукцию
          вида: $ A \rightarrow \sigma $, где $ A \in N $, а
          $ \sigma \in \Sigma^* $. Другими словами простые правила вывода --
          это продукции, которые содержат только терминальные символы в
          правой части.
    \item Сложным правилом будем называть любое не простое правило, то есть
          правило в правой части которого есть нетерминальные символы.
\end{itemize}

Введем отношение порядка на простых правилах вывода. Будем говорить, что
простое правило $ r_0 = A_0 \rightarrow \alpha_0 $ меньше чем простое
правило $ r_1 = A_1 \rightarrow \alpha_1 $, или $ r_0 < r_1 $,
если $ \alpha_0 < \alpha_1 $ в лексикографическом смысле.
Таким же способом определим отношение меньше либо равно на простых правилах.

Будем считать, что на сложных правилах отношение порядка не определено.

Опишем алгоритм нахождения $ \alpha_{\min} $.
\begin{enumerate}
    \item Найдем все простые правила вывода в грамматике $ G $ и положим
          в неупорядоченное множество $ H $.
    \item Если $ H $ пусто, пишем на экран \verb|IMPOSSIBLE| и выходим из
          алгоритма, в противном случае ищем наименьшее правило в $ H $
          $ r = A \rightarrow \sigma $ и достаем его из множества.
    \item Если $ |\sigma| > k $, пишем на экране \verb|IMPOSSIBLE| и выходим
          из алгоритма.
    \item Если $ A = S $, то пишем на экране $ \sigma $ и выходим из
          алгоритма.
    \item Удаляем из грамматики все продукции с нетерминалом $ A $ в левой
          части.
    \item Для всех правил $ q = B \rightarrow \beta $, где $ \beta $ содержит
          нетерминал $ A $, заменяем $ A $ на $ \sigma $. Если после этой
          замены правило $ q $ становится простым, то добавляем его в $ H $.
    \item Переходим к шагу 2.
\end{enumerate}

Другими словами, на каждом шаге алгоритма мы ищем наименьшую строку
выводимую из любого выбранного нетерминала грамматики $ G $, которая также
будет наименьшей строкой, выводимой из своего нетерминала. После нахождения
такой строки мы изменяем $ G $, удаляя найденный нетерминал, а также заменяя
его во всех оставшихся правилах на наименьшую строку выводимую из него.
Итерации продолжаются, пока очередная наименьшая строка меньше чем $ k $, а
также нетерминал строки не равен $ S $, так как обратное означает, что
найденная строка является наименьшей выводимой из $ S $, а значит и искомой
$ \alpha_{\min} $.

В случае, когда $ H $ опустело, а $ \alpha_{\min} $ еще не найдена,
это означает, что грамматика $ G $ пришла в такое состояние, что все ее
правила имеют нетерминалы в правой части. Это значит ни один терминал не
является порождающим. Отсюда следует, что нетерминал $ S $ также не является
порождающим и то, что язык задаваемый грамматикой пуст. Как следствие,
$ \alpha_{\min} $ не существует.


\subsection{Доказательство.}
Приведенный выше алгоритм базируется на нескольких утверждениях.

\paragraph{Утверждение 1.} Для любого правила вывода
$ r = \alpha_0 B_1 \alpha_1 ... B_n \alpha_n $, где
$ \alpha_i \in \Sigma^*$, $ B_i \in N $ и $ n \ge 0 $, наименьшая
выводимая с помощью него строка $ \alpha_{\min}^r $ имеет вид
$ \alpha_0 \beta_1 \alpha_1 ... \beta_n \alpha_n $, где
$ \beta_i $ -- это наименшая строка выводимая из нетерминала $ B_i $.

Допустим обратное, тогда наименьшая возможная строка выводимая с
помощью правила $ r $ имеет вид
$ \alpha_0 \beta_1 \alpha_1 ... \beta'_j \alpha_j ... $, где $ \beta'_j $
не является наименьшей строкой выводимой из нетерминала $ B_j $, а строки
$ \beta_i $ $ i < j $ являются наименьшими выводимыми из $ B_i $.
Но тогда
строка $ \alpha_0 \beta_1 \alpha_1 ... \beta_j \alpha_j ... $, где
$ \beta_j $ наименьшая выводимая из $ B_j $ строка, лексикографически меньше
чем $ \alpha_0 \beta_1 \alpha_1 ... \beta'_j \alpha_j $. Противоречие.

Утверждение верно и в обратную сторону, если все $ \beta_i $ наименьшие
выводимые из соответствующих нетерминалов $ B_i $ строки, то
$ \alpha_0 \beta_0 \alpha_1 ... \beta_n \alpha_n $ -- наименьшая выводимая
из $ r $ строка. По практически тем же соображениям.

\paragraph{Утверждение 2.} Наименьшая строка из любого выбранного
нетерминала грамматики $ G $, или другими словами, наименьшая строка
выводимая из любого правила вывода грамматики $ G $, выводится из
наименьшего простого правила вывода грамматики $ G $.

Допустим, что наименьшая строка выводится из сложного правила
$ r = A \rightarrow \alpha_0 B_0 ... $, где $ \alpha_0 \in \Sigma^* $ и
$ B_0 \in N $, тогда из утверждения 1 следует, что наименьшая строка
выводимая правилом $ r $ будет $ \alpha_0 \beta_0 ... $, но эта строка
уже больше либо равна $ \beta_0 $, которая выводится из $ B_0 $. Так как
мы вывели $ \beta_0 $ из $ B_0 $, то $ B_0 $ является пораждающим
нетерминалом, а значит, выводя $ \beta_0 $ из $ B_0 $ мы использовали
как минимум одно простое правило вывода $ q = C \rightarrow \gamma $,
где $ \gamma \le \beta_0 $. Это значит что эта же строка выводится и
из простого правила, либо полученная с помощью $ r $ строка не является
наименьшей.

Из этой части доказательства становится ясно, что наименьшая строка
как минимум выводится из простых правил грамматики. По очевидным
соображениям она выводится из наименьшего простого правила -- это следует
из определения.

Таким образом на каждом шаге алгоритма мы находим именно наименьшую
выводимую строку, так как достаем наименьшее простое правило из кучи.

Теперь проверим правильность условий останова.

Так как простое правило выводит наименьшую строку по сравнению с любым
правилом грамматики $ G $, то очевидно, что эта строка является наименьшей
для нетерминала в левой части из этого правила. Отсюда становится очевидным,
что если нетерминал в левой части это $ S $, то строка в правой части это
решение, при условии, что она меньше чем $ k $.

И опять же, если текущая наименьшая строка грамматики на данной итерации
имеет длину большую $ k $, то дальшейшие поиски не имеют смысла, так как из
$ S $ мы выведем строку большую либо равную по длине текущей наименьшей
строке по сравнению со строками выводимыми из любого правила грамматики,
а значит строку длиннее $ k $.

Случай с опустевшим множеством $ H $ рассмотрен в конце описания алгоритма.
Таки образом итерационный процесс и условия останова алгоритма верные.

\subsection{Сложность до оптимизации.}
Сложность по времений $ O(C^2 + C \cdot |G|) $,
где $ C $ -- это число порождающих нетерминалов из $ G $, фактически в
задаче $ C \le 10 $ по условию, а также, скорее всего, подразумевается
$ |G| >> C $, поэтому можно говорить о асимптотике $ O(C \cdot |G|) $,
правда стоит говорит о том что квадрат в сложности получается во время
сравнения строк сопоставимых с $ |G| $, но в этом случае можно оптимизировать
алгоритм не добавляя в $ H $ простые правила, длина правых частей которых
больше $ k $.

Сложность по памяти $ O(|G|) $.

\subsection{Оптимизации}
\begin{enumerate}
    \item За линейное время можно найти все nullable нетерминалы,
          если $ S $ -- nullable, вывести ответ, если нет, удалить
          все такие нетерминалы из правил грамматики.
    \item За линейное время можно найти все порождающие нетерминалы
          и удалить не порождающие и продукции содержащие их в правой части.
    \item После проведенных выше оптимизаций можно утверждать, что любой
          нетерминал грамматики порождает минимум 1 символ, как следствие
          все правила $ r = A \rightarrow \alpha $, где $ |\alpha > k | $
          можно удалить, так как они порождают строки длиной больше чем
          $ k $, а нас такие строки не интересуют.
    \item За линейное время можно удалить из грамматики все правила вида
          $ r = A \rightarrow ... A ... $, так как эти правила не влияют
          на наименьшую строку порождаемую нетерминалом $ A $, фактически
          это можно сделать еще во время чтения грамматики.
\end{enumerate}

С введенным препроцессингом грамматики, учитывая, что $ k \le 20 $, алгоритм
фактически будет работать за $ O(|G|) $ только за время препроцессинга,
так как описанные действия существенно сократят и изменят исходную
грамматику. А в общем асимптотика на работоу алгоритма станет
$ O(|G| + C^2 + C \cdot |G'|), $ где по сравнению с размером исходной 
рамматики $ G $, вторым и третьим
членом можно принебречь, сказав, что это константа, где $ C = 10 $, а
$ |G'| = C \cdot k_{\max} = 200 $.

\subsection{Доказательсвто обоснованности оптимизаций}
Если $ S $ не nullable, то очевидно, что все правила с nullable
нетерминалами можно удалить, а также удалить их из правых частей правил.
Так как фактически именно это и сделает алгоритм без оптимизаций в самом
начале, потому что $ \epsilon $ наименьшая из всех возможных строк.

Удаление непорождающих нетерминалов и правил их содержащих не изменит языка
определяемого грамматикой, а значит и наименьшую выводимую строку это
тоже не изменит.

\paragraph{Утверждение 3.} Первые два шага препроцессига гарантируют, что для
любого нетерминала $ A \in N' $ грамматики $ G' $, полученной после
препроцессинга, наименьшая строка $ \sigma \in \Sigma^* $ выводимая из $ A $
имеет длину $ |\sigma| \ge 1 $.

Второй шаг препроцессинга нам нужен, чтобы гарантировать, что из $ A $ можно
вывести хотя бы одну строку $ \sigma $, другими словами, что $ \sigma $ вообще
существует, так как $ A $ -- порождающий нетерминал.

Допустим теперь, что из $ A $ можно вывести $ \epsilon $, тогда $ A $ -- это
nullable, но все nullable мы удалили на первом шаге препроцессинга.
Противоречие.

Утверждение 3 позволяет нам удалить все правила, правая часть которых длиннее
$ k $, так как наименьшая выводимая с помощьюу этого правила строка будет
длиной большей чем $ k $, а следовательно на наименьшую выводиму строку
длиной не больше $ k $, это правило не повлияет.

Ну и последний препроцессинг обоснован, так как не меняет наименьшую строку
$ \alpha^A_{\min} $ порождаемую нетерминалом $ A $, то есть правило
$ r = A \rightarrow ... A ... $, очевидно, порождает строку меньше либо
равную $ \alpha^A_{\min} $, а также так как $ A $ порождающий нетерминал,
то существет правило $ q = A \rightarrow w $, где $ w $ не содержит $ A $ и
которое прождает $ \alpha^A_{\min} $, а значит мы можем удалить правило
$ r $.

\subsection{Итоговая сложность.}
Сложность по времений $ O(|G| + C^2 + C \cdot |G'|) $,
где $ C $ -- это число порождающих нетерминалов из $ G' $, $ G' $ грамматика
полученная после шага препроцессинга. Можно сказать, что
$ O(C^2 + C \cdot |G'|) = O(const) $, тогда сложность получится $ O(|G|)$.
Сложность по памяти $ O(|G|) $.

\end{document}
