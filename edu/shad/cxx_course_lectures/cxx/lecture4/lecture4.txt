date:26.09.12
... Рассказ про svn. ...

*** Обращаясь к предыдущей лекции

    Каноническое решение семинарских задач:
    """
        #include<iostream>
        #include<string.h>

        // Чтобы исключить конфликты имен используем свой namespace
        namespace MyNamespace {
            // Будет конфликт с string.h
            // Если namespace-а не будет
            int strlen(char const * s) {
                int len = 0;
                while(*s++) ++len;
                return len;
            }

            char * strcpy(char * dest, const char * source) {
                char * oldDest = dest;
                while (*dest++ = *source++);
                return oldDest;
            }

            char * starcat(char * dest, const char * source) {
                char * oldDest = dest;
                strcpy(dest + strlen(dest), source);
            }
        }

        // Если сделать так:
        // using MyNamespace::strlen;
        // Тоже будет конфликт имен

        int main() {
            const char * s = "Hello!";
            // char * s = "Hello!"; // Не компилируется.

            char * d = new char[100];
            MyNamespace::strcpy(d, s);

            std::cout << MyNamespace::strlen(s) << std::endl;
            std::cout << d << std::endl;

            delete [] d;
        }
    """

*** ? про const
    """
        // копия a
        void f_just_copy(T a) {
            // Тут можно менять a, сама переменная переданная в функцию не изменится
            // Не стоит передавать большие объекты
        }

        // копия указателя на a
        void f_copy_pointer(T * a) {
            // Собственно можно менять.
        }
        // Зато когда вызываем
        // Явно видно, что, наверное, будет изменяться переменная.
        T x;
        f_copy_pointer(&x);

        // Теперь давайте смотреть 3-ий способ
        void f_reference(T & a) {
            // Передается ссылка -- такой <<указатель>>.
            // Можно менять a даже не делая операцию обращения по адресу(*a)
            a = 5;
        }

        // так f(const T a)
        // или
        void f(T const & a) {
        // const коммутирует
            // теперь a менять нельзя
        }

        //void f(const T a);
        void f(T const * a) {
        // Это тоже идентичные объявления
            a = b;
            // *a = b; нельзя!!!
        }

        void f(T const * const a) {
           // a = b запрещено!!
           // *a = b запрещено!!
        }

        void f(T * const a) {
            // a = b запрещено!!
            *a = b;
        }
    """

    Обычно const не пишут перед простыми типами
    (int, char, bool, double)
    Потому что стоймость копирования указателя и переменной простого типа фактически
    ничего не стоит.

    Когда вы передаете просто тяжелый объект(например контейнер) и предполагаете, что он не будет меняться
    то лучше передавать объект по константной ссылке.

    """
        f_const(int const & a) {
            // делаем что-либо
        }

        f(int a) {
            // делаем что-либо
        }

        // f(1); ошибка компиляции.
        f_const(1);
    """

    В google code style, если объект должен меняться, то нужно передавать его по указателю.

    """
        f(T * const a) {
            // Например, забыли поставить звездочку
            a = 0;
            // Но ошибка не пройдет уже на этапе компиляции.
            // PROFIT
        }
    """

***
    С функциями можно работать практически также как и с переменными.
    """
    // На примере уже имеющихся strcat, strlen, strcpy

    int main() {
        // Объявим указатель на функцию с такой-то сигнатурой
        char * (*f) (char *, const char *);
        // Как читать вот такую запись?
        // Скобки диктуют приоритет. А дальше читаем то что справа, потом слева.
        // f -- это указатель на функцию с сигнатурой (char *, const char *) которая возвращает указатель на char.
        
        // Почувствуй разницу ;)
        char * * p [10];
        // p это массив из 10 элементов -- указателей на указатели char
        char * (*p) [10];
        // p это указатель на массив из 10 элементов -- указателей на char.

        const char * s = "Hello!";
        char * d = new char[100];

        // d = ничего
        f = MyNamespace::strcpy;
        f(d, s);
        // d = "Hello!";

        f = MyNamespace::strcat;
        f(d, s);
        // d = "Hello!Hello!";

        delete [] d;
    }

    """

    По хорошему надо бы писать:
    """
        f = &MyNamespace::strcpy;
        (*f)(d, s);
    """

    Но язык С++ делает все за нас, поэтому можно и не делать этого.
    Таким образом мы написали так называемый функтор.

    ? Где используются функторы?
    Нашей сегодняшней задачей будет:
    Написать функцию, которая находит корень монотонной функции методом деления пополам.

    Также вспомним библиотечную функцию std::sort, в которую можно передать
    функциию которая возвращает bool, которая заменит operator<. Таким образом мы
    сможем <<отсортировать>> массив как хотим.

    Напишем функцию максимум.
    """
        #include<iostream>

        int max(int a, int b) {
            return a < b ? b : a;
        }

        double max(double a, double b) {
            return a < b ? b : a;
        }

        // Так можно писать много и долго.
        // Но лучше применить шаблон
        template <typename T>
        T max(T a, T b) {
            return a < b ? b : a;
        }
        // Никакой реальный код не сгенерируется,
        // пока мы не попробуем эту функцию вызвать.

        int main() {
            int a = 1, b = 2;
            double x = 100.0, y = 43.1;

            // Компилятор сам <<подберет>> нужный нам тип.
            std::cout << max(a, b) << std::endl;
            std::cout << max(x, y) << std::endl;
            // Подберет по типу аргументов.
            // Но сложности начнуться когда мы начнем смешивать
            std::cout << max(a, x) << std::endl;
            std::cout << max(x, a) << std::endl;
            // Тут компилятор скорее всего поругается на нас.
            // Разрешить это можно явно указав тип для функции
            std::cout << max<double>(a, x) << std::endl;
        }
    """

    ? А как компилятор отличает угловые скобки шаблона от operator< и operator>.
    - Из контекста.

    """
        template <int N> {
        int AddN(int x) {
            return x + N;
        }

        int main() {
            std::cout << AddN<10>(4) << std::endl;
            // Вот такие вещи приводят к двусмысленности
            // std::cout << AddN< x > y >(4) << std::endl;
            // Поэтому стоит поставить скобки
            std::cout << AddN< (x > y) >(4) << std::endl;
        }

    """

    Было доказано, что такой обобщенный язык полный. Следовательно можно вычислить что-нибудь
    хорошее на момент компиляции с помощью подобных конструкций.

    Шаблоны это круто, но они могут приводить к различным двусмысленным конструкциям.

    На этом мы наверное и закончим... -- уже половина восьмого.
