date(03.09.12)
... просьба 1 issue на все дз полностью
*** "Давайте пойдем дальше, сегодня контейнеры stl" (c)
    С какими то контейнерами мы уже знакомы, это vector и map.

    Линейные или последовательные контейнеры:
    (те которые мы можем представить как непрерывный кусок памяти)



    * std::vector

    Вектор резервирует зарание достаточно большоей кусок памяти
    и собственно пишет в этот кусок памяти. Если места нам уже не
    хватает, то происходит реаллокация:
    [ ] Выделяется больший кусок памяти.
    [ ] Копируется все что было в старом куске в новый.
        Note: копирование это всегда нечто сложное, так как 
        копируемые объекты могут быть достаточно сложны по структуре. 
        Так что для копирования используется конструктор копирования.
    [ ] Освобождаем старый.

    Какие операции можно сделать с вектором почти бесплатно:
    * Добавление в конец (Если не нужна реаллокация).
    * Удалять с конца (Гарантируется, что стандартный вектор не
      использует реаллокацию -- сказали, что так по стандарту).
    * Доступ по элементу.



    * std::list

    Список, имеется ввиду двунаправленный неинтрузивный список.

    Есть специальный объект -- элемент списка. В нем есть:
    [ ] данные
    [ ] указатель на предыдующий элемент
    [ ] указатель на следующий элемент

    Есть обертка для элемента, который хранит все описаное выше.
    Это есть неинтрузивность списка.

    Оценим сложность операций:
    * добавление и удаление элемента O(1)
    * Индексация уже O(n)

    ? Выделять память это же долго?
    - Как работает ОС:
      Выделяет куски памяти по запросу.
      Выделили 1, выделили 2, выделили 3...
      А далее удалили 2. Получается пустой кусок
      между 1 и 3(происходит фрагментация памяти).
      Но есть способ перехетрить операционную систему: написать свой
      менеджер памяти, который попросит большой кусок у ОС, а дальше
      будет выдавать программе из своего куска место так, как нам надо.



    * std::deque (Doulbe Ended QUEue)

    Двусторонняя очередь.

    Представим два вектора
    Один растет влево, другой вправо.
    <----------|--------->

    Зная длины наших двух векторов, мы можем сравнительно легко
    выполнять индексацию.

    Итого, быстро:
    * push_back();
    * push_front();
    * pop_back(); // удалить с конца
    * pop_front(); // удалит с начала
    * Индексация

    Но опять же не учитываем реаллокацию при добавлении элементов.
    Также могут возникнуть случаи в которых оказывается пуст левый или
    правый вектор и делается pop_front() или pop_back(), но это все
    каким-то хитрым образом балансируется.



    * std::string

    "Много функций у строки -- смотрите документацию" (c) Учителъ.


    Все эти конейнеры мы будем называть линейными контейнерами.

    Над этими линейными контейнерами, существуют несколько адаптеров,
    которые используют линейные контейнеры для своей реализации.

    * std::stack<T, необязательный параметр>.

    Второй необязательный параметр -- линейный контейнер, который будет
    выбран за основу для реализации.
    По умолчанию это, как нистранно, deque.

    Операции:
    * void push(const T & value);
    * void pop();
    * T & top() const;
    * size_t size() const;
    * bool empty() const;

    Почему pop возвращает void()...?
    Потому что могут возникнуть проблемы с типом T.
    Дело в том, что создание нового объекта типа T
    может сам сгенерировать исключительную ситуацию.
    Проблема в универсальности. Получается
    несогласованное состояние, когда pop уже удалил
    элемент из стека, а вернуть не смог из за исключения.

    Note: в деструкторах нельзя генерировать исключения
    Это было легкое отступление.

    Поймем почему ничего не скомпилируется если вторым параметром
    отправить std::stack.
    Внутри стека где-то хранится этот объект, который является основой
    для стека.
    Очевидно empty, size -- просто возвращают то, что возвращает основа.
    А ведь push, должен вызвать push_back... а у стека такой функции нет.
    Кстати, соответственно, pop -- pop_back(), top -- back().



    * std::queue<T, необязательный уже знакомый нам параметр>
    Тоже сделан на основе std::deque


    * std::priority-queue<T, необязательная основа>
    Дефолтный необязательный контейнер vector<T> по версии cplusplus.com
    Умеет ставить элементы в очередь

    Адаптеры закончились.



    Дальше, кстати, список ассоциативных(нелинейных) контейнеров.
    * std::map
    Реализация на красночерных деревьях

    * std::multimap

    * std::set
      map в котором игнорируются все значения -- одни ключи.

    * std::multiset

    В C++11 включили std::unordered_map и std::unordered_set.
    А в старом стандарте забыли включить хэш таблицы, чем по сути
    является ordered_map.



*** Что еще нам очень важно сегодня узнать???

    Мы посмотрели на то какие бывают контейнеры, а нам нужно еще
    узнать то, какие бывают итераторы.

    Итераторы бывают разные, очевидно, что для вектора и для списка
    они должны отличаться.

    * Random Access iterator (итератор произвольного доступа)
    [ ] it + 10
    [ ] it - 2
    [ ] it[8]
    [ ] it1 - it2
    (deque, vector, string ... все что с произвольным доступом)

    * Bidirectional iterator (Двунаправленный итератор)
    [ ] ++it; it++;
    [ ] --it; it--;
    // it + 1 нельзя
    (list)

    ? А у map итераторы какого тип?
    - У map кстати bidirectional.

    * Forward iterator (Однонаправленный итератор)
    [ ] ++it; it++;
    [ ] *it
    // ... Все.


    * Input и Output iterator (Итераторы ввода и итераторы вывода)
    Представьте себе, что у вас не контейнер, а какой либо поток.
    Нам надо прочитать текущий символ, чтобы прочитать дальше.
    Причем, если мы прочитали(считали с итератора), то он сдвинется
    дальше и прочитать то, что уже было снова не получится.
    [ ] *it; // И после того как он вернет текущее, сдвинется на следующее.
    [ ] it-> ; // Пока еще не прошли, поэтому умолчали.
    [ ] it1 != it2; // 
    [ ] it++; ++it; // формально есть, но он ничего не делает?
                    // хотя зависит от реализации.
    // ... Все


 *** Что такое обобщенный алгоритм?
    Сами по себе контейнеры не особо полезны.
    Было бы полезно иметь алгоритмы работающие на этих контейнерах.

    Естесственно алгоритмы тоже хочется написать обобщенно.
    Эти алгоритмы будут использовать не сами объекты, а неких посредников
    чтобы работать с контейнерами -- это итераторы.

    Например хотим sort для итераторов произвольного доступа.
    Нам нужны границы.

    Напишем функцию copy, несмотря на то, что такая есть в стандартной
    библиотеке.

    """
        template <typename T, typename R>
        R copy(T begin, T end, R dest) {
            while(begin != end) {
                *dest++ = *begin++;
            }

            return dest;
        }

        // Как использовать

        int a[10]; // как то заполненный
        std::vector<int> b(10);
        list<int> c(10);

        std::copy(a, a + 10, b.begin());
        std::copy(b.begin(), b.end(), c);
        std::copy(c.begin(), c.end(), a);
        std::copy(c.rbegin(), c.rend(), a); // Перевернули последовательность!
    """

    Мы можем даже посылать input и output итераторы!!!
    Именно чтобы такой код работал для input и output итераторов
    ++ ничего для них делает(просто фиктивно существует)
