date: 19.09.2012
Давайте двигаться дальше.

*** Pointers.

    Мол укозатели привязаны к типу данных.

    """
        int a = 123
        int * p = &a;

        // *p то что хранится в памяти по адресу p
        (*p)++; // Постфикс более приорететен, поэтому скобки

        // Можно прибавить число
        p + 13; // указывает на 13*sizeof(int) "дальше" чем p
        p + 1;  // соседний инт
        // Собственно привет перемещению по массивам.
    """

    К примеру sizeof(int) == 4

    *p                        *(p + 2)
    [ ][ ][ ][ ]#[ ][ ][ ][ ]#[ ][ ][ ][ ]
                              или p[2]
                              или (2 + p)
                              отсюда удивительное
                              2[p] -- правильная
                              конструкция!!!

    2[p] преобразуется компилятором в *(2 + p)
    Эта эквивалентность имеет место лишь для базовых типов

    Вернемся к объявлению:
    """
        int * p; // Сейчас p может означать что-угодно. =>
        *(p + 2) = 0; // => Вполне может быть SEGFAULT
    """

    Работать с массивом можно, когда на момент компиляции
    известна его длина.
    
    Объявим массив:
    """
        int a[10];
        a[0] = 17; // собственно a есть указатель на первый эл-т массива.
        *a = 17;   // Абсолютно эквивалентная строчка. Тут неявно происходит
                   // преобразование массива в указатель
        int *p = a + 9;
        p[-1] = 30; // обращаемся к a[8]
        a[1] = 123;
        a[9] = 222; // ОК
        a[10] = 20; // Беда!!! Скорее всего SEGFAULT
    ...
    """


    Стандарт гарантирует довольно неажиданную штуку:
    """
    ...
        int * r = a + 10; // Можно хранить вот такой указатель.
        std::sort(a, a + 10); // Отсортирует массив от начала до конца

        int * l = a + b; // если b>10 Тут стандарт ничего не гарантирует.
    """
    Этот хитрый указатель нужен чтобы обозначить конец массива.
    Можно просто ориентироваться по этому a + arraySize указателю.
    Разыменовывать этот указатель, к счастью, нельзя.

    Между указателями допустимы сравнения (за константное время)
    <, >, <= и >=

    Пройдем по массиву указателей и напечатаем элементы:
    """
        #define arraySize 20;
        int a[arraySize];

        // version 1
        for (int i = 0; i < arraySize; ++i)
            std::cout << a[i] << " ";
        // лучше писать
        //for (int i = 0; i != arraySize; ++i)

        // version 2
        for (int * p = a; p != a + 10; ++p)
            std::cout << *p << " ";

        // Note: Можно считать, что a(указатель на начало массива) 
        // Note: это константный указатель

        // vector version
        std::vector<int> v;
        for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); ++p)
            std::cout << *p << " ";

    """
    Понятно, что итераторы есть для всех стандартных контейнеров

    ? Чем отличается const_iterator от обычного iterator
    - Очень правильный вопрос!
    Код для вектора -- не совсем аналог "массивному" коду. Для аналога
    нам нужно стереть const_(оставить просто iterator)

    Константный указатель и указатель на константу, а еще
    Константный указатель на константу
    """
        int const N = 10;
        // Легко читается справа на лево
        // "N -- константа типа инт"

        const int * p; // справа на лево "p указатель на константу типа инт"
        int const * p; // const int и int const эквивалентны
        int * const p = &b; // справа на лево "p константный указатель на инт"

        int const * const p = &b;
        // "p константный указатель на константу типа инт"
        // Можно только читать, менять нельзя НИЧЕГО
        // Ни указатель, ни то что там лежит
    """

    Есть плохой оператор который снимает константность const_cast --
    Очень не рекомендуется употреблсять сие выражение.
    Так что гарантии на константность в с++ нет. При желании все испортить --
    вы все испортите.

    Итератор -- это отличная абстракция которая есть чтобы обходить структуру
    данных. "При этом она прикидывается указателем" (c)

    const_iterator -- аналог указателя на константу.

    Внимание вопрос:
    Если мне вдруг надо объявить итератор который является аналогом констаного
    указателя на что-то -- что же делать?
    """
        const std::vector<int>::iterator p = v.begin();
    """

    Note: Тут прошел слух, что v.begin() можно что-либо присвоить...
    """
        // Наивный вариант
        void f(std::vector<int> v) {
            v[0] = 10;
        }
        // Проблема в том, что в функцию передается копия v
        // То есть с самим вектором ничего не произойдет
        // Функция будет работать только с копией
        f(v); // вектор не изменится

        // В языке C это делалось с помощью указателей
        void f_like_c(std::vector<int> * v) {
            (*v)[0] = 10
        }
        f_like_c(&v);

        // В C++ можно передавать параметр по ссылке
        // Тогда функция будет работать именно с тем
        // объектом, который мы передаем в функцию

        void f2(std::vector<int> & v) {
            v.clear();
        }
        f2(v); // Мы отчистили v

        void f3(const std::vector<int> & v) {
            v.clear(); // Не скомпилируется
        }
        // clear -- не константный метод
        // а у нас в аргументе константная ссылка
    """

    Тяжелые, сложные объекты передаем в функцию по
    константной ссылке.

    "Это косается чего угодно больше 8 байт" (c)

    По сути просто передача по ссылке (у гугла) запрещена:
    Снаружи не видно, что функция может изменить объект.
    В Си-подобном случае:
    В вызове мы явно должны передать ссылку(f(&m)) --
    так явно видно, что объект меняется.

    "Давайте напишем с вами кусок кода..." (c)
    """
        // Напишем функцию меняющую две переменные местами
        void swap(int& a, int& b) {
            int c = b;
            b = a;
            a = c;
        }

        swap(0, 1); // Написать нельзя, так как у 0 и 1 нет адреса в памяти
        // У меня в gcc 4.6.1 не компилируется
    """

    "Пишите как можно более выразительно!" (c)
    """
        int n = 10;
        while (n-->0) { // (n--) > 0
        }
    """

    копирование строк
    """
        void strcpy(char * a, const char * b) {
            // variant 1
            for(;*b != 0; ++b) {
                *a = *b;
                ++a;
            }
            *a = 0;
            // получился невыразительный код

        }

        // variant 2
        void strcpy(char * a, const char * b) {
            while (*a++ = *b++); // Выразительный код!
        }
    """

    """
        char * c = new char[N]; // Выделить кусок памяти размером N * sizeof(char)
        // На начало этого куска станет указывать c
        // К слову, N может быть не известно на момент начала компиляции.

        strcpy(c, "Hello, world!");

        // действие c нашим массивом данных, например.

        delete[] c; // Обратите внимание на []
        // Это есть удаление массива.
    """
    Собственно откуда компилятор знает тот размер N???
    Ответ: знает -- он где-то рядом с нашим массивом c, это N записывает.

    "A!.. Задачку разобрать:" (c)
    """
        int i, n = 20;
        for (i = 0; i < n; --i)
            printf("+");

        // 3 способа
        //for(i = 0; -i < n; --i)
        //for(i = 0; i < n; --n)
        //for(i = 0; i + n; --i)
    """
