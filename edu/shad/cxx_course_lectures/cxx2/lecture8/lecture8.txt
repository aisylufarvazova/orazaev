!date(10.04.13)
    *** Начинаем разбираться с python.
    Основы, динамическая типизация.
    """
        print c
    """
    По дефолту print печатает перевод строки, чтобы этого не было
    можно добавить в конец ,
    """
        >>> C = "ABC"
        >>> print c, c,
        ABC ABC
        >>>
    """
    """
        >>> print "%d" % (12,), "it is good"
        12 it is good
        >>>
    """

    К слову print в спецификации 3.x перестал быть оператором и стал
    функцией.


    Строки и последовательности(кортежи(tuple)) не изменяемы. Их можно только
    взять и изменить целиком.

    Изменяемы же списки(list), словари и множества.

    Примеры с join и split.
    """
        >>> s = ['a', 'b', 'c']
        >>> s
        ['a', 'b', 'c']
        >>> str(s)
        "['a', 'b', 'c']"
        >>> "".join(s)
        'abc'
        >>> "====".join(s)
        'a====b====c'
        >>> t = "a,b,c"
        >>> t.split(',')
        ['a', 'b', 'c']
        >>>
    """


    Словари
    """
        >>> a = {"Jan":31, "Feb":28, "Mar":31}
        >>> a
        {'Jan': 31, 'Mar': 31, 'Feb': 28}
        >>> for key in a:
        ...   print key, a[key]
        ...
        Jan 31
        Mar 31
        Feb 28
        >>> a["Mar"]
        31
        >>> a["May"]
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        KeyError: 'May'
        >>> a["May"] = 31
        >>> a
        {'Jan': 31, 'May': 31, 'Mar': 31, 'Feb': 28}
        >>> del a["Jan"]
        >>> a
        {'May': 31, 'Mar': 31, 'Feb': 28}
        >>>
    """

    Надо признать сами словари не могут быть ключами словарей,
    так как словари изменяемы.

    Все изменяемые контейнеры ведут себя как ссылки, поэтому
    для копирования нужно использовать либо конструктор, либо
    срезку.
    """
        >>> a
        {'May': 31, 'Mar': 31, 'Feb': 28}
        >>> b = a
        >>> a[123] = 3
        >>> a
        {123: 3, 'May': 31, 'Mar': 31, 'Feb': 28}
        >>> b
        {123: 3, 'May': 31, 'Mar': 31, 'Feb': 28}
        >>> del a[123]
        >>> b = dict(a)
        >>> a[123] = 3
        >>> a
        {123: 3, 'May': 31, 'Mar': 31, 'Feb': 28}
        >>> b
        {'May': 31, 'Mar': 31, 'Feb': 28}
        >>>
    """


    О генераторах:
    """
        >>> [3*x for x in xrange(1, 10)]
        [3, 6, 9, 12, 15, 18, 21, 24, 27]
        >>> [3*x for x in xrange(1, 10) if x %2 == 0]
        [6, 12, 18, 24]
        >>>
    """

    О None:
    """
        >>> a = None
        >>> a
        >>> print a
        None
        >>> type(a)
        <type 'NoneType'>
        >>>
    """

    В питоне нет закрытых полей в классах, но соглашением по
    именованию они помечаются подчеркиваниями.

    Отличная справачная система:
    """
        >>> help(list)
    """

    Питон умеет двойные неравенства:
    """
        >>> a = 7
        >>> if 1 < a <= 10:
        ...   print True
        ...
        True
        >>>
    """

    Немного о функциях. Это тоже объекты.

    """
        #-*- coding: utf-8 -*-

        print u'Привет, мир!'
    """


    Как работать с файликами
    Имеем файлик:
    """
        Привет, Мир!
        Да здравствует питон
    """

    """
        import sys
        for s in sys.stdin:
            print s.rstrip()
    """

    """
        f = open(sys.argv[1])
        for s in f:
            print s.rstrip()

        f.close()
    """


    В питоне по умолчанию есть поддержка функционального программирования.
    Начнем с лямбд
    """
        >>> s = [(1,2), (-3,4), (10, -2), (0, 0)]
        >>> s
        [(1, 2), (-3, 4), (10, -2), (0, 0)]
        >>> s.sort()
        >>> s
        [(-3, 4), (0, 0), (1, 2), (10, -2)]
        >>> s.sort(lambda x, y: cmp(x[::-1], y[::-1]))
        >>> s
        [(10, -2), (0, 0), (1, 2), (-3, 4)]
        >>>
    """

    map и reduce
    """
        >>> s = [1,2,3,4,5]
        >>> map(lambda x: x * x, s)
        [1, 4, 9, 16, 25]
        >>>
        >>> reduce(lambda x, y: x + y, s)
        15
        >>>
        >>> reduce(lambda x, y: x * y, s, 1)
        120
        >>>
    """

    О zip:
    """
        >>> A = [[1,2,3,4], [5,6,7,8]]
        >>> def printMatrix(M):
        ...   for row in M:
        ...     for item in row:
        ...       print item,
        ...     print ""
        ...
        >>> printMatrix(A)
        1 2 3 4
        5 6 7 8
        >>>
        >>> printMatrix(zip(*A))
        1 5
        2 6
        3 7
        4 8
        >>>
    """

    Последовательность *A может развернуть последовательность
    и передать в качестве аргументов элементы списка.
    "Как будто сняли внешние скобки"


    О аргументах функции:
    """
        >>> def f(a,b,c, *lst, **kv):
        ...   print a, b, c
        ...   print lst
        ...   print kv
        ...
        >>> f(1,2,3,4,5,6,7,8,d="Hello",e=12)
        1 2 3
        (4, 5, 6, 7, 8)
        {'e': 12, 'd': 'Hello'}
        >>>
        >>>
        >>>
        >>>
        >>> f(**{"a":1,"b":2,"c":3,"d":4})
        1 2 3
        ()
        {'d': 4}
        >>> f(a=1,b=2,c=3)
        1 2 3
        ()
        {}
        >>>
    """
    Так пишутся функции с переменным числом аргументов.


    """
        >>> s
        [1, 2, 3, 4, 5]
        >>> s.reverse()
        >>> s
        [5, 4, 3, 2, 1]
        >>> for i in sorted(s):
        ...     print i
        ...
        1
        2
        3
        4
        5
        >>> filter(lambda x: x%2 == 0, s)
        [4, 2]
        >>> s
        [5, 4, 3, 2, 1]
        >>>
    """

    Еще давайте расскажу про множества set
    """
        >>> s = set()
        >>> s.add((1,2,3))
        >>> s.add(123)
        >>> s
        set([123, (1, 2, 3)])
        >>> t = set((123, 34))
        >>> t
        set([34, 123])
        >>> s & t
        set([123])
        >>> s | t
        set([34, 123, (1, 2, 3)])
        >>> s ^ t
        set([34, (1, 2, 3)])
        >>> s.difference(t)
        set([(1, 2, 3)])
        >>> s - t
        set([(1, 2, 3)])
        >>>
    """
