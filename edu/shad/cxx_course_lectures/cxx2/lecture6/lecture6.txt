!date(27.03.2012)
*** Рассказ про ошибки в векторе
    - Выделяем именно сырую память (дабы не конструировать дефолтные элементы)

    Сегодня я хотел бы рассказать вам о C++11 (С++0x)

    Предпологаются C++14(косметические изменеия 11-ого стандарта) и
    C++17 -- тут уже стауструп и копания представят разные новые концепты.



    Первая интересная штука про которую хочется рассказать -- это move-конструсторы
    или конструктноры перемещения.

    Бывают случаи, когда нам не хочется именно копировать. Например вернуть
    большой объект из функции. Если отключить return-value-optimization(RVO),
    то у нас будут лишние, ненужные копирования.
    Другой пример: умные укозатели, например auto_ptr, где нужно передавать
    владение. Для того чтобы написать конструктор копирования приходилось
    убирать слово const, либо использовать const_cast. Ни то не другое не
    является best-practice.

    Move-constructor
    """
        class Class {
            Class() { }
            void fun(const Class& other) { ...; gun(tmp); }
            void fun(Class &other) { ...; gun(tmp); }

            // Ссылка на временный объект (некое rvalue)
            // компилятор отдаст предпочтение этой функции
            // для временных объектов
            void fun(Class &&tmp) { ...; gun(tmp); }

            void gun(const Class& other) { ... }
            void gun(Class &other) { ... }
            void gun(Class &&tmp) { ... }
        };

        int main() {
            Class c1;
            c1.fun(c1); // вызов fun(Class &other) и gun(Class &other)

            c1.fun(Class()); // вызов fun(Class &&other) а далее
                             // gun(Class &other)

            const Class c1;
            c1.fun(c1); // вызов fun(const Class& other) и
                        // gun(const Class& other)
        }
    """

    Для того чтобы вызвать gun(Class &&tmp) из fun(Class &&tmp) надо
    написать:
    """
        void fun(Class &&tmp) { ...; gun(std::move(tmp)); }
    """

    Когда вы пишите выражение у вас в этом выражении могут появляться
    временные переменные, которые живут только до конца строки
    (до точки входа).

    Например если мы пишем вектор на C++11, то мы должны написать
    ему move-constructor, а в нем мы уже просто коприруем все указатели
    rvalue конструируемому вектору, а далее сбрасываем в 0 все указатели
    временного объекта, чтобы тот в своем деструкторе не почистил нам
    всю память в указателях.


    Другая штука про которую хочется рассказать -- это новый смысл
    ключевого слова auto.
    Из за avto контейнерам пришлось добавть cbegin() и cend() для
    константных итераторов.

    Кстати о итерации по контейнерам.... (плавно переходим к for each)
    """
        for (int& x : container) expr;
    """
    Компилятор это автоматически преобразует в код с итераторами, но
    это работает и для низкоуровневых СТАТИЧЕСКИХ массивов (так как
    компилятор умеет определить размер только статических массивов)


    Списки инициализации.
    """
        struct s {
            int a;
            double b;
        }

        int main() {
            s = {1, 2.71};
            int s[3] = {
                {0, 2.71},
                {1, 3.14},
                {2, 5}
            };
        }
    """
    Теперь это работает и для векторов!

    Теперь конструкция:
    """
        {1, 2, 3};
    """
    Это std::initializer_list. А каждый уважающий себя
    контейнер умеет принимать std::initializer_list
    как аргумент конструктора.

    Отсюда вырос вот этот синтаксис:
    """
        int x{5};
    """



    decltype(expr). Определить тип по expr
    """
        std::vector<int> v {1, 2, 3};
        decltype(v[0]) x; // то же самое что int x;
    """



    "Вроде если я не наврал, то можно писать вот так":
    """
        auto f(const V& val) -> decltype(val) {
            ...
        }
    """


    А есть еще такая штука которая называется lmabda-функция!
    """
        []() { ... }
    """
    Есть такая шаблонная стандартная функция for_each, теперь
    функции, которые надо передавать for_each можно создавать на лету:
    """
        for_each(a, a + N, [](int x) {std::cout << x;});
    """
    Квадратные скобки -- нужны для определения замыкания(об этом чуть позже)
    Круглые скобки -- аргументы
    Возвращаемое значение -- у нас в примере не написано, но можно вот так:
    """
        [](int x) -> int { return x + 10; }
    """
    Ну и тело в конце.

    Теперь что же такое [] и замыкание. В этих квадратных скобках мы можем
    указать какие внешние переменные лямбда функция должна видеть.

    Теперь можно вот так:
    """
        int a[N] = { .... }
        int sum = 0;
        for_each(a, a + N, [&sum](int x) { sum += x; });
    """

    Относиться надо к этому так, что компилятор за нас пишет класс-функтор,
    который хранить в своем поле ссылку на sum.

    """
        [&](){...}; // захват всего что есть в области видимости по ссылке
        [=](){...}; // захват всего что есть в области видимости по значению
    """

    Программа которая допустима в новом стандарте:
    """
        int main(){[](){}();}
    """



    Последняя конструкция, про которую я хочу рассказать --
    это variated templates.

    Вспомним printf:
    """
        printf("hello, %s! Happy new %d year!", "Kostya", 2014);
    """
    Давайте представим как это вообще может быть написано?
    Она написана с помощью оператора ...
    которое позволяет передавать произвольное число аргументов.
    Это все дело опасное, так как если мы ошибемся с буквами или
    числом параметров или порядком параметров, то будут беды.

    Что же такое variated templates:
    """
        class A {};
        class B {};

        template <typename ... Args>
        class C: public Args ... {
        public:
            void f() const {
                // вывести число аргументов
                std::cout << sizeof...(Args) << std::endl;
            }
        };

        int main() {
            C<A> c;
            C<A, B> d;
            c.f(); // печатает 1
            c.f(); // печатает 2
        }
    """


    Что мы можем делать?
    Обрабатывать по одному аргументу, например!
    """
        template <typename T, typename ... Args>
        void f(T t, Args ... args) {
            do_stuff<T>(t);
            f(args);
        }
    """




    ?А как же constexp?!?!??!!?
    - А... constexpr


    """
        const int M = 5;
        int array[M];

        int f() {
            return 5;
        }

        int foo[f()]; // oops! Ошибка компиляции!

        constexpr int cf() { // Гарантируется вычисление на этапе компиляции.
            return 5;
        }

        int foo[cf()]; // Все ок!
    """

    Эти функции не могут объявлять свои переменные, свои типы.
    Параметры должны быть константные.

    """
        template <int N>
        constexpr int f(int a) {
            return N + a;
        }

        int array[f<4>(5)];
    """
