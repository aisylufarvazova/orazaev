!date(20.03.13)
    *** Ругают за векторы в ДЗ.
    У многих было решение, где в векторе хранится массив
    элементов типа T. Это плохое решение, так как при инициализации
    вектора массив будет проинициализирован дефолтными значениями
    типа T. Но T может быть сложным типом, конструирование которого
    дорого.

    Еще были проблемы с exception safety и как следствие с утечками
    памяти при выбрасывании исключений.


    Сегодня речь пойдет про множественное наследование.

    ЯП с множественным наследованием:
    *) C++
    *) Python
    *) Smalltalk
    *) ... (еще несколько)

    Во некоторых современных языках используется множественное
    наследование интерфейсов: C# и Java.
    На интерфейсы наложено много запретов:
    - Нет реализации
    - Нет данных

    В С++ мы же если наследуем -- так наследуем "на широкую руку"
    данные, методы ... в ход идет все что было в классе предке.

    Как это примерно выглядит в памяти (зависит конечно от компилятора):
    class B: public A { ... }
    *-------*
    | A | B |
    *-------*
    Можно обратиться по указателю к объекту класса B как к объекту класа C.

    class C: public A, public B { ... }
    *-----------*
    | A | B | C |
    *-----------*

    """
        class A { ... int x; ... };
        class B : public A { ... };
        class C : public A { ... };
        class D : public B, public C { ... };

        D d;

        // И у нас 2 абсолютно разных x.
        d.B::x;
        d.C::x;
    """
    *---------------------------*
    | *-------* | *-------* |   |
    | | A | B | | | A | C | | D |
    | *-------* | *-------* |   |
    *---------------------------*

    Для решения проблемы ромбовидного наследования было придумано
    виртуальное наследование.

    """
        class A { ... int x; ... };
        class B : virtual public A { ... };
        class C : virtual public A { ... };
        class D : public B, public C { ... };
    """
    *-----------------------*
    | A | B \ A | C \ A | D |
    *-----------------------*

    Фактически мы в объектах B и С храним теперь не объект A
    целиком, а храним указатель на этот объект. Происходит
    косвенная адресация объекта базового класса.
    class B:
    *--------*
    | A* | B |
    *--------*

    Механизм похож на механизм работы виртуальных функций, поэтому
    собственно и слово ключевое то же.

    Пример из стандартной библиотеки где используется на виртуальное
    наследование: <iostream>. (istream, ostream)

    ? Как же это влияет на sizeof ?
    - Вычитается размер A и добавляется sizeof A*.

    Как правило в реальности аллоцированный объект А лежит __где-то__ рядом.


    Как раньше работал конструктор:
    """
        class A { ... };
        class B : public A { ... };

        B b;
    """
    1) инициализируется A.
    2) инициализируются собственные поля B.
    3) выполняется тело конструктора.

    Как это будет с можественным наследованием:
    """
        class B { ... };
        class C { ... };
        class D : public B, public C { ... };

        D d;
    """
    1) Инициализируется B.
    2) Инициализируется С.
    3) Инициализируются собственные поля D.

    А теперь с ромбовидным наследованием.
    """
        class A { ... int x; ... };
        class B : virtual public A { ... };
        class C : virtual public A { ... };
        class D : public B, public C { ... };

        D d;
    """
    1) Инициализируется A.
    2) Тут умный компилятор __НЕ__ инициализирует второй раз A.
    3) Инициализируются собственные поля В.
    4) Тут умный компилятор __НЕ__ инициализирует второй раз A.
    5) Инициализируются собственные поля C.
    6) Инициализируются собственные поля D.

    Конструктор для D выглядит так:
    """
        D()
            : A(...)
            , B(...)
            , C(...)
            , /* D fields */
        { }
    """


    При написании конструкторов важно было инициализировать
    поля в порядке их объявления.

    Подтип(можно копировать с помощью memcpy) / Неподтип.
    Подтипы не инициализируются если они не указаны в списке
    инициализации. Если их не инициализировать, то там будет
    мусор.

    """
        struct A {
            A() : foo('A');
            char foo; // char -- подтип
            char bar;
            B baz;
        };

        A theA;
        theA.foo; // Здесь 'A'.
        theA.bar; // Здесь "что в памяти лежало" (мусор).
        theA.baz; // Тут B().
    """


    Проблемы с именами:
    """
        class A {
        public:
            int x;
        };

        class B : virtual public A {
        public:
            void foo() { }
        };

        class C : virtual public A {
        public:
            // void foo() { }  -- нельзя конфликт имен.
            void foo(int) { }
        };

        class D : public B, public C {
        };

        D d;
        d.foo(); // B::foo();
        d.foo(0); // C::foo();
    """


    Виртуальная загадка!
    """
        class A {
        public:
            int x;
            virtual void foo() = 0;
        };

        class B : virtual public A {
        public:
            virtual void foo() { }
        };

        class C : virtual public A {
        public:
            virtual void foo() { }
        };

        class D : public B, public C {
        };

        D d;
    """

    Такой код не скомпилируется.
    Так как D не сможет правильно построить таблицу виртуальных
    функций, так как не понятно какую из foo(B или С) выбрать.




    Самое время поговорить об операторах преобразования типов:
    static_cast<T>(expr)
        Он "static_" как можно заметить и это не случайно --
        так как он разрешается на этапе компиляции.
        Если у класса есть оператор преобразования к T, то вызовется
        этот оператор, если же нет будет попытка вызвать T(expr).

    dynamic_cast<T>(expr)
        Дополнительно проверка в рантайме. Для полиморфных структур.
        """
            A * a = new A;
            // B * b = static_cast<B*>(a); Беда. Нас за руку не поймают.
            B * b = dynamic_cast<B*>(a); // Ошибка времени выполнения.
        """

    const_cast<T>(expr)
        Снять константность с объекта expr.
        П.С. Не очень хорошо чаще всего стоит задуматься о правильности
        архитектуры.

    reinterpret_cast<T>(expr)
        В стандарте сказано лишь следующее, что если делать
        reinterpret_cast<void*>(T*) а потом обратно, то результат будет
        одинаковым.
        Непереносим с little-endian в big-endian.
        Непероносимы "более строгие" требования по выравниванию.
        Нужен лишь для того чтобы какой-либо набор байт(например из файла)
        преобразовать к примеру в строку. Еще используется для сравнивания
        void*.

    (T) (expr) // Притребление в старом стиле C.
        Cначала компилятор попробует привести c помощью static_cast,
        потом dynamic_cast, потом const_cast и в конце концов с помощью
        reinterpret_cast.

