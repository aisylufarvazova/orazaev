!date(20.02.13)
    *** Сначала небольшой тест(20 вопросов)

    *** Теперь разбор.
    1) Ошибка
        char *a = "abcd";
        char b[] = "abcd";
        sizeof a; // 4 (размер указателя)
        sizeof b; // 5 (размер массива)

    2) Ошибка:
        overwise: // метка, которая скомпилируется

    3) Ошибка:
        std::find нельзя использовать с map.
        вместо этого можно использовать метод std::map::find(const TKeyType& key).

    4) Ошибка:
        Провафлил передачу константы в метод ожидающий ссылку.

    5) Ошибка:
        Провафлил, просто провафлил.
        Не увидел, что 2 функции одинаковы.


    *** Лекция
    Кратко о семестре:
        1) C++
        2) Python

    По C++ будет 2 ДЗ. ~6 занятий.
    И будет еще одно ДЗ по python.


    Сегодня поговорим об обработке исключений и безопасности исключений.
    RAII (Resource ... Initial Initialization)
    Эта концепция приведет нас к умным указателям, а также к перегрузке new.

    Далее, рассмотрим преобразование типов и множественное наследование.
    Чуть позже поговорим о новом стандарте C++11.



    Классическая задача:
    Есть два класса:
    """
    class X {
    };

    class Y {
    };

    class Z {
        X * x;
        Y * y;
        // В конструкторе выделяем x и y, в деструкторе удаляем.
    };
    """

    Зачем это может быть надо:
    1) Полиморфизм
    2) Слишком тяжелые x и y, которые могут переполнить стек.
    3) Время жизни x и y больше чем z.
    4) Быстрый swap.
    5) Массив объекто x и y.
    6) Отложенная инициализация x и y. Во время создания z мы еще не можем
       создать x и y, например потому что не хватает каких-нибудь данных,
       которые надо подсунуть в конструкторы x и y.


    Пишем наивно.
    """
        class Z {
            X * x;
            Y * y;
        public:
            Z() {
                x = new X();
                y = new Y();
            }

            ~Z() {
                delete x;
                delete y;
            }
        };
    """

    Проблемы:
    1) y при создании кидает исключение, тогда z еще не создаться, значит и
       деструктор вызывать не на что, НО мы уже выделили память под x и
       потекли программой.

    Исправляем наивно:
    """
        class Z {
            X * x;
            Y * y;
        public:
            Z() {
                x = new X();
                try {
                    y = new Y();
                } catch(...) {
                    delete x;
                    throw;
                }
            }

            ~Z() {
                delete x;
                delete y;
            }
        };
    """

    Следующие проблемы:
    1) Написанные по дефолту компилятором:
        *) конструктор копирования
        *) оператор присваивания.

    Исправляем далее:
    """
        class Z {
            X * x;
            Y * y;
        public:
            Z() {
                x = new X();
                try {
                    y = new Y();
                } catch(...) {
                    delete x;
                    throw;
                }
            }

            Z(const Z& other) {
                x = new X(*other.x);
                try {
                    y = new Y(*other.y);
                } catch(...) {
                    delete x;
                    throw;
                }
            }

            // Стандартный способ написать operator =
            // Через конструктор копирования
            Z& operator = (const Z& rhs) {
                if (this == *rhs) {
                    return *this;
                }

                Z tmp(z);
                swap(tmp);
                return *this;
            }

            void swap(Z& z) {
                std::swap(x, z.x);
                std::swap(y, z.y);
            }

            ~Z() {
                delete x;
                delete y;
            }
        };
    """

    Хочется иметь универсальное простое решение. Это решение
    и есть умные указатели.

    Умные указатели реализуют идеому RAII.

    """
        template <typename T>
        class Holder {
            T * data;
        public:
            Holder() {
                data = new T();
            }

            ~Holder() {
                delete data;
            }

            operator T * () const {
                return data;
            }
        };

        class Z {
            Holder<X> x;
            Holder<Y> y;
        public:
            Z() {   // Теперь можно оставить пустым!
            }
            ~Z() {  // Теперь тоже можно остаить пустым!!
            }

            // Правда мы еще не решили проблему с копированием и присваиванием.
        };
    """

    В старом стандарте есть только std::auto_ptr, в новом их стало больше.

    "Выделение ресурса всегда должно мыслиться как создание объекта!" (c)




    Гарантии безопасности исключений.
    1) Базовая гарантия.
       Произошло исключение, мы гарантируем, что объект останется в согласованном
       хотя может быть и необычном состоянии.
       Пример: есть вектор, после добавления элемента произошло исключение, но
       size() правильный, и не затронутые элементы остались в неизмененном состоянии.

    2) Строгая гарантия.
    """
        vecotr<T> v;
        ...
        const T& a = v.back();
        ...
        v.push_back(t);
    """
       Мы понимаем, что если произошла реаллокация, то ссылка станет невалидной.
       Строгая гарантия, это если при сбое в push_back, ссылка a останется
       валидной.
       То есть мы гарантируем, что вообще ничего не пострадает.
       Решение с вектором: просто сделать временный вектор, в него добавить элемент,
       а далее сделать безопасный swap.
    3) Гарантия бессбойности: Программа вообще не кидает исключений.
       Деструктор и swap должны давать гарантии бессбойности.


    Устное ДЗ: возьмите std::vector и подумайте какую гарантию безопасности
    эти функции гарантируют.


    Часто вспоминают про стек, где:
    """
        void pop();
        T top();
    """
    Специально не совмещая эти функции (pop ничего не возвращает),
    чтобы гарантировать строгую безопаснось.
