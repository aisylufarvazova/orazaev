===================================
Лекции по курсу С++. ШАД 2012-2013.
===================================

:author: Алексей Зобнин
Оформил текст Аман Оразаев. (aorazaev@gmail.com)


***********************************
Лекция 2. Операторы.
***********************************

Префиксный и постфиксный инкремент
===================================
Префиксный и постфиксный инкременты -- это операторы языка. Вместо тысячи слов:

.. code:: c++

    int i = 10;
    int k = ++i;
    /// Теперь k = i = 11
    i = 10;
    k = i++;
    /// Теперь k = 10; i = 11;


Префиксный оператор возвращает ссылку на объект, в то
время как постфиксный временный объект.

    Унарный плюс для целых тоже является оператором.

Вопрос на засыпку: скомпилируются ли следующие выражения,
а если скомпилируются то, что будет происходить?

.. code:: c++

    int x = 1;
    ++++x;

.. code:: c++

    int x = 1;
    ++x++;

Вот примеры постфиксных операторов:
  - []
  - ()
  - ++
  - ->
  - .
  - :\:
  - ->*
  - .*

Мнемонический прием:
Как правило, в с++ постфиксные операторы
всегда выполняются раньше префиксных.


lvalue и rvalue
===================================
lvalue
    Под lvalue может пониматься нечто, что имеет адрес в памяти,
    причем это нечто должно быть изменяемым. Как правило lvalue
    мы можем поставить слева от оператора присваивания.

Рассмотрим пример:

.. code:: c++

   int a, b;
   a = b;

В вышепреведенном примере ``a`` не может быть объявлена константой
или константной переменной.

Вопрос на засыпку: скомпилируется ли следующий фрагмент? Если да, то что будет происходить?:

.. code:: c++

   int i = 0;
   ++i = 5;

Приоритет оператора равно ниже чем у префиксного инкремента. Поэтому сначала выполнится префиксный инкремент, вернет lvalue на i, после чего в i запишется 5.


О типах.
===================================
Согласно стандарту самый маленький тип -- `char`.
Все остальные типы считаются отнасительно `char`. Размер этих типов зависит от используемой платформы. Стандарт гаратнирует лишь следующее::
   char <= short int <= int <= long int <= long long int

.. note:: В 99.9% случаев размер `char` равен 1 байт.
.. note:: В названиях типов (short|long|long long) int слово int можно не указывать.

Как правило разработчики чтобы их типы были платформонезависимы определяют свои типы вроде `i8` (`int` восьмибитный) `u16` (`unsigned` шестнадцатибитный).

Получить размер типа можно с помощью оператора `sizeof`.
Вопрос на засыпку: Чему равно следующее выражение?
.. code:: c++
   sizeof 'a';


Побитовые операторы.
===================================
Числа хранятся в виде битов, соответсвенно к ним применимы бинарные операции:
&
    Побитовое и.
|
    Побитовое или.
xor
    Побитовое исключающее или.
~
    Побитовое отрицание.
>> и <<
    Побитовые сдвики вправо и влево соответственно.

Знаковый бит сохраняется на своем месте, но при этом распространяется при использовании оператора сдвига.
Вопрос на засыпку: Каков будет результат выполнения следующих выражений?
.. code:: c++
   1 >> 1;
   -1 >> 1;

Проверка четности числа используя побитовые операторы:
.. code:: c++
   int x = 12;
   assert(x % 2 == ~(x & 1));


О скорости работы постфиксного и префиксного инкремента.
===================================
Когда в качестве аргумента выступает обычная интегральная переменная, то разницы в скорости мы не заметим, потому что компилятор оптимизирует все за нас.

Если же мы используем какой-нибудь сложный объект, например, итератор для контейнера, то скорее всего компилятор не поймет что тут оптимизировать.

В нижепреведенном коде есть беда:
.. code:: c++
   std::vector<int> v = std::vector(1000);
   for (std::vector::const_iterator ci = v.begin();
        ci != v.end();
        ci++)
   {
       ci;
   }

Беда эта заключается в том, что каждый раз, когда цикл будет выполнять постфиксный инкремент на `ci`, мы будем создавать временный объект итератор, который нам не нужен совсем. Поэтому правильно было бы использовать префиксный итератор.

.. note:: Совет от классиков: старайтесь вообще везде использовать префиксный инкремент, если только это не помешает выразительности кода.

А. Зобнин:
> Правильней было бы назвать язык не C++, а ++C.
