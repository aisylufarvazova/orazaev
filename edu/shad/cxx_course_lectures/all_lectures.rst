===================================
Лекции по курсу С++. ШАД 2012-2013.
===================================

:author: Алексей Зобнин
:Student: Аман Оразаев. (aorazaev@gmail.com)


***********************************
Лекция 2.
***********************************

Операторы.
===================================

Префиксный и постфиксный инкремент
-----------------------------------
Префиксный и постфиксный инкременты -- это операторы языка. Вместо тысячи слов:

.. code:: c++

    int i = 10;
    int k = ++i;
    /// Теперь k = i = 11
    i = 10;
    k = i++;
    /// Теперь k = 10; i = 11;


Префиксный оператор возвращает ссылку на объект, в то
время как постфиксный временный объект.

.. note:: Унарный плюс для целых тоже является оператором.

Вопрос на засыпку: скомпилируются ли следующие выражения,
а если скомпилируются то, что будет происходить?

.. code:: c++

    int x = 1;
    ++++x;

.. code:: c++

    int x = 1;
    ++x++;

Вот примеры постфиксных операторов:
  ``[]``, ``()``, ``++``, ``->``, ``.``, ``::``, ``->*``, ``.*``

.. tip:: Мнемонический прием:
    Как правило, в с++ постфиксные операторы
    всегда выполняются раньше префиксных.


lvalue и rvalue
-----------------------------------
lvalue
    Под lvalue может пониматься нечто, что имеет адрес в памяти,
    причем это нечто должно быть изменяемым. Как правило lvalue
    мы можем поставить слева от оператора присваивания.

Рассмотрим пример:

.. code:: c++

   int a, b;
   a = b;

В вышепреведенном примере ``a`` не может быть объявлена константой
или константной переменной.

Вопрос на засыпку: скомпилируется ли следующий фрагмент? Если да, то что будет происходить?:

.. code:: c++

   int i = 0;
   ++i = 5;

Приоритет оператора равно ниже чем у префиксного инкремента. Поэтому сначала выполнится префиксный инкремент, вернет lvalue на i, после чего в i запишется 5.


О типах
-------
Согласно стандарту самый маленький тип -- `char`.
Все остальные типы считаются отнасительно `char`. Размер этих типов зависит от используемой платформы. Стандарт гаратнирует лишь следующее::

   char <= short int <= int <= long int <= long long int

.. note:: В 99.9% случаев размер `char` равен 1 байт.
.. tip:: В названиях типов (short|long|long long) int слово int можно не указывать.

Как правило разработчики чтобы их типы были платформонезависимы определяют свои типы вроде `i8` (`int` восьмибитный) `u16` (`unsigned` шестнадцатибитный).

Получить размер типа можно с помощью оператора `sizeof`.
Вопрос на засыпку: Чему равно следующее выражение?

.. code:: c++

   sizeof 'a';


Побитовые операторы
-------------------
Числа хранятся в виде битов, соответсвенно к ним применимы бинарные операции:

``&``
    Побитовое и.

``|``
    Побитовое или.

``xor``
    Побитовое исключающее или.

``~``
    Побитовое отрицание.

``>>`` и ``<<``
    Побитовые сдвики вправо и влево соответственно.

Знаковый бит сохраняется на своем месте, но при этом распространяется при использовании оператора сдвига.
Вопрос на засыпку: Каков будет результат выполнения следующих выражений?

.. code:: c++

   1 >> 1;
   -1 >> 1;

Пример применения побитовых операторов: проверка четности числа:

.. code:: c++

   int x = 12;
   assert(x % 2 == ~(x & 1));


О скорости работы постфиксного и префиксного инкремента
-------------------------------------------------------
Когда в качестве аргумента выступает обычная интегральная
переменная, то разницы в скорости мы не заметим, потому
что компилятор оптимизирует все за нас.

Если же мы используем какой-нибудь сложный объект,
например, итератор для контейнера, то скорее всего
компилятор не поймет что тут оптимизировать.

В нижепреведенном коде есть беда:

.. code:: c++

   std::vector<int> v = std::vector(1000);
   for (std::vector::const_iterator ci = v.begin();
        ci != v.end();
        ci++)
   {
       ci;
   }

Беда эта заключается в том, что каждый раз, когда цикл будет
выполнять постфиксный инкремент на `ci`, мы будем создавать
временный объект итератор, который нам не нужен совсем. Поэтому
правильно было бы использовать префиксный итератор.

.. tip:: Совет от классиков:
    старайтесь вообще везде использовать префиксный инкремент,
    если только это не помешает выразительности кода.

"Правильней было бы назвать язык не C++, а ++C." А. Зобнин.


Логические операторы
--------------------
Логические операторы в языке:
    ``==``, ``!=``, ``&&``, ``||``, ``>=``, ``>``, ``<=``, ``<``

Приоритет операторов сравнения выше чем у ``||`` или ``&&``.
Иногда вместо того чтобы использовать ``if`` можно воспользоваться
оператором ``? :`` (один из немногих операторов, которые нельзя
перегружать)

.. code:: c++

    session.isAuthenticated() ? doStuff(session) : session.login();

Инструкциями в языке называют условный оператор ``if``, оператор цикла
``while``, ``return`` и так далее.

.. note:: Есть такой оператор '``,``'.

    Он имеет самый низкий приоритет, бинарный. Он последовательно
    вычисляет лсначала левую часть, затем правую. Возвращает
    результат вычислений в правой части.

Хитрости с '``,``':

.. code:: c++

    int x = 10;
    int y, a, b, c
    double d;
    x > y ? (a, b, c) : d;

Вопрос: где мы можем перегружать оператор запятая?
Ответ: например класс-многочлен. Оператор запятая будет
вычислять НОД, например:

.. code:: c++

    TPolynom f, b, d;
    (f, b, d);

Если существует какой-либо бинарный оператор (условно ``@``), то
оператор ``@=`` применимо к ``a @= b`` будет обозначать ``a = a @ b``.

.. note:: Считается, что оператор ``a @= b`` быстрее чем ``a = a @ b``.
    Так как не нужно выделять дополнительной памяти для хранения
    результата.

.. tip:: Обычная практика: сначала писать оператор ``@=``, а потом
    ``a @ b`` через него. Иногда так делать не стоит (например при
    перемножении матриц так делать не стоит)

    .. code:: c++

        class ToupleOf2Ints {
        public:
            ToupleOf2Ints(int x, int y)
                : x(x)
                , y(y)
            { }

            ToupleOf2Ints(const ToupleOf2Ints& other)
                : x(other.getX())
                , y(other.getY())
            { }

            const ToupleOf2Ints& operator+=(const ToupleOf2Ints rhs) {
                x += rhs.x;
                y += rhs.y;
                return * this;
            }

            ToupleOf2Ints operator+(const ToupleOf2Ints rhs) const {
                ToupleOf2Ints copy(* this);
                return copy += rhs;
            }

        private:
            int x;
            int y;
        };

На этом разговор об операторах хотелось бы закончить.



Указатели и массивы.
====================

В двух строчках:

.. code:: c++

    int * p = 0;
    int k = 23;
    p = &k;
    assert(* p == 23);
    * p = 13;
    assert(k == 13 && * p == 13);

Массивы
-------
Массив на пальцах
    непрерывный кусок памяти в котором лежат одинаковые
    объекты. Чтобы работать с массивом, надо знаеть его
    начало (указатель на начало), поэтому указатели
    очень хорошо дружат с массивами.


Стандартный алгоритм сортировки:

.. code:: c++

    std::vector<int> k;
    /// Заполнение вектора.
    std::sort(k.begin(), k.end());

, элементы в такой сортировке будут сравниваться с помощью
стандатного оператора ``<``

Если мы хотим отсортировать как-то по другому, то нужно
писать пользовательскую функцию сравнения и передать в ``sort``
третьим, необязательным параметром.

.. code:: c++

    bool my_cmp(int lhs, int rhs) {
        return a > b;
    }

    std::vector<int> k;
    /// Заполнение вектора.
    std::sort(k.begin(), k.end(), my_cmp);


Домашнее чтение:
  - `Устройство даффа`__

.. __: http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%94%D0%B0%D1%84%D1%84%D0%B0





****************************
Лекция 3
****************************

Указатели
=========

Указатели привязаны к типу данных:

.. code:: c++

   int a = 123
   int * p = &a;

   // * p то что хранится в памяти по адресу p
   (* p)++; // Постфикс более приорететен, поэтому нужны скобки

   // Можно прибавить число
   p + 13; // указывает на 13*sizeof(int) "дальше" чем p
   p + 1;  // соседний инт
   // Собственно привет перемещению по массивам.

К примеру ``sizeof(int) == 4``, тогда память будет выглядеть вот так:

+---------------+---------------+---------------+
|     ``*p``    | ``*(p + 1)``  | ``*(p + 2)``  |
+---+---+---+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+---+

Где каждый пустой квадратик, это байт.

.. note:: ``*(p + 2)`` эквивалентно ``p[2]``, что эквивалентно
    ``*(2 + p)`` и отсюда фокус: ``2[p]`` тоже корректое выражение
    языка. Оно преобразуется в ``*(2 + p)``, но эта эквивалентность
    имеет место лишь для базовых типов.

Вернемся к объявлению:

.. code:: c++

    int * p; // Сейчас p может означать что-угодно. =>
    * (p + 2) = 0; // => Вполне может быть SEGFAULT

Работать с массивом можно, когда **на момент компиляции** известна его длина.
Это означает что шаблонная магия будет работать с массивами.

Объявим массив.

.. code:: c++

    int a[10];
    a[0] = 17; // собственно a есть указатель на первый эл-т массива.
    * a = 17;  // Абсолютно эквивалентная строчка. Тут неявно происходит
               // преобразование массива в указатель
    int * p = a + 9;
    p[-1] = 30; // обращаемся к a[8]
    a[1] = 123;
    a[9] = 222; // ОК
    a[10] = 20; // Беда!!! Скорее всего SEGFAULT

Но, стандарт гарантирует довольно неожиданную штуку:

.. code:: c++

    int b;
    int * r = a + 10; // Можно хранить вот такой указатель.
    std::sort(a, a + 10); // Отсортирует массив от начала до конца
    int * l = a + b; // если b>10 Тут стандарт ничего не гарантирует.


Этот хитрый указатель нужен чтобы обозначить конец массива.
Можно просто ориентироваться по этому ``a + arraySize`` указателю.
Разыменовывать этот указатель, к счастью, нельзя.

Между указателями допустимы операции сравнения (за константное время)
``<``, ``>``, ``<=`` и ``>=``.

Пройдем по массиву указаттелей и напечатаем элементы:

.. code:: c++

    #define arraySize 20;
    int a[arraySize];

    // version 1
    for (int i = 0; i < arraySize; ++i)
        std::cout << a[i] << " ";
    // лучше писать
    //for (int i = 0; i != arraySize; ++i)

    // version 2
    for (int * p = a; p != a + 10; ++p)
        std::cout << * p << " ";

    // Можно считать, что a(указатель на начало массива)
    // это константный указатель

    // vector version
    std::vector<int> v;
    for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); ++p)
        std::cout << * p << " ";

Понятно, что итераторы есть для всех стандартных конейнеров.
Итератор -- это отличная абстракция которая есть чтобы обходить структуру
данных. При этом она "прикидывается указателем".

const и указатели.
------------------
С помощью ``const`` можно объявить константный указатель,
указатель на константу, а еще константный указатель на константу!

.. code:: c++

    int const N = 10;
    // Легко читается справа на лево
    // "N -- константа типа инт"

    const int * p; // справа на лево "p указатель на константу типа инт"
    int const * p; // const int и int const эквивалентны
    int * const p = &b; // справа на лево "p константный указатель на инт"

    int const * const p = &b;
    // "p константный указатель на константу типа инт"
    // Можно только читать, менять нельзя НИЧЕГО
    // Ни указатель, ни то что там лежит

.. note:: Есть плохой оператор который снимает константность ``const_cast``.
    Очень не рекомендуется употреблсять это выражение.  Так что гарантии
    на константность в с++ нет. При желании все испортить -- вы все
    испортите.

``const_iterator`` -- аналог указателя на константу.

Вопрос на засыпку: как объявить итератор который является аналогом
константного указателя на нечто?

.. code:: c++

    std::vector<int> v;
    const std::vector<int>::iterator it = v.begin();

Передача аргумента по ссылке.
-----------------------------
Допустим надо передать аргумент вектор в функцию, это можно сделать
несколькими путями:

.. code:: c++

    // Наивный вариант
    void f(std::vector<int> v) {
        v[0] = 10;
    }
    // Проблема в том, что в функцию передается копия v
    // То есть с самим вектором ничего не произойдет
    // Функция будет работать только с копией
    f(v); // вектор не изменится

    // В языке C это делалось с помощью указателей
    void f_like_c(std::vector<int> * v) {
        (* v)[0] = 10
    }
    f_like_c(&v);

    // В C++ можно передавать параметр по ссылке
    // Тогда функция будет работать именно с тем
    // объектом, который мы передаем в функцию

    void f_by_ref(std::vector<int> & v) {
        v.clear();
    }
    f_by_ref(v); // Мы отчистили v

    void f_by_const_ref(const std::vector<int> & v) {
        v.clear(); // Не скомпилируется
    }
    // clear -- не константный метод
    // а у нас в аргументе константная ссылка

Тяжелые, сложные объекты стоит передавать в функцию по константной
ссылке. "Это касается чего угодно больше 8 байт" A. Зобнин.

.. note:: По сути просто передача по ссылке (у гугла в стайлгайде)
    запрещена.  Снаружи не видно, что функция может изменить объект.
    В Си-подобном случае: в вызове мы явно должны передать
    ссылку(``f(&v)``) -- так явно видно, что объект меняется.


Примеры выразительного кода
---------------------------
"Пишите как можно более выразительно!" А. Зобнин:

.. code:: c++

    int n = 10;
    while (n-->0) { // (n--) > 0
        // Шутка над тем, что n стремится к 0.
    }

.. code:: c++

    void strcpy(char * a, const char * b) {
        // variant 1
        for(;*b != 0; ++b) {
            * a = * b;
            ++a;
        }
        * a = 0;
        // получился невыразительный код

    }

    // variant 2
    void strcpy(char * a, const char * b) {
        while (* a++ = * b++); // Выразительный код!
    }

Задачка: в нижепреведенном фрагменте кода измените один символ, чтобы
программа печатала 20 плюсов:

.. code:: c++

    int i, n = 20;
    for (i = 0; i < n; --i)
        printf("+");

Ответ:

.. code:: c++

    // 3 способа
    //for(i = 0; -i < n; --i)
    //for(i = 0; i < n; --n)
    //for(i = 0; i + n; --i)


****************************
Лекция 4
****************************

Возвращаясь к предыдущей лекции приводятся канонические решения семинарских
задач. (написать свою версию ``strlen``, ``strcpy``, ``strcat``)

.. code:: c++

    #include<iostream>
    #include<string.h>

    // Чтобы исключить конфликты имен используем свой namespace
    namespace MyNamespace {
        // Будет конфликт с string.h
        // Если namespace-а не будет
        int strlen(char const * s) {
            int len = 0;
            while(* s++) ++len;
            return len;
        }

        char * strcpy(char * dest, const char * source) {
            char * oldDest = dest;
            while (* dest++ = * source++);
            return oldDest;
        }

        char * starcat(char * dest, const char * source) {
            char * oldDest = dest;
            strcpy(dest + strlen(dest), source);
        }
    }

    // Если сделать так:
    // using MyNamespace::strlen;
    // Тоже будет конфликт имен

    int main() {
        const char * s = "Hello!";
        // char * s = "Hello!"; // Не компилируется.

        char * d = new char[100];
        MyNamespace::strcpy(d, s);

        std::cout << MyNamespace::strlen(s) << std::endl;
        std::cout << d << std::endl;

        delete [] d;
    }


Функторы
========
С функциями можно работать практически как с переменными:

.. code:: c++

    // На примере уже имеющихся strcat, strlen, strcpy

    int main() {
        // Объявим указатель на функцию с такой-то сигнатурой
        char * (* f) (char * , const char * );
        // Как читать вот такую запись?
        // Скобки диктуют приоритет. А дальше читаем то что справа, потом
        // слева.  f -- это указатель на функцию с сигнатурой
        // (char * , const char * ) которая возвращает указатель на char.

        // Почувствуй разницу ;)
        char * * p [10];
        // p это массив из 10 элементов -- указателей на указатели char
        char * (* p) [10];
        // p это указатель на массив из 10 элементов -- указателей на char.

        const char * s = "Hello!";
        char * d = new char[100];

        // d = ничего
        f = MyNamespace::strcpy;
        f(d, s);
        // d = "Hello!";

        f = MyNamespace::strcat;
        f(d, s);
        // d = "Hello!Hello!";

        delete [] d;
    }

По хорошему надо бы писать:

.. code:: c++

    f = &MyNamespace::strcpy;
    (* f)(d, s);

Но язык С++ делает все за нас, поэтому можно и не делать этого.
Таким образом мы написали так называемый функтор.

Где использовать функторы? Например, когда мы пишем функцию, которая
ищеть корень монотонной функции методом дихотомии. Также вспомним
библиотечную функцию ``std::sort``, в которую можно передать
функциию которая возвращает ``bool``, которая заменит ``operator<``.
Таким образом мы сможем "отсортировать" массив как хотим.

Напишем функцию максимум:

.. code:: c++

    #include<iostream>

    int max(int a, int b) {
        return a < b ? b : a;
    }

    double max(double a, double b) {
        return a < b ? b : a;
    }

    // Так можно писать много и долго.
    // Но лучше применить шаблон
    template <typename T>
    T max(T a, T b) {
        return a < b ? b : a;
    }
    // Никакой реальный код не сгенерируется,
    // пока мы не попробуем эту функцию вызвать.

    int main() {
        int a = 1, b = 2;
        double x = 100.0, y = 43.1;

        // Компилятор сам <<подберет>> нужный нам тип.
        std::cout << max(a, b) << std::endl;
        std::cout << max(x, y) << std::endl;
        // Подберет по типу аргументов.
        // Но сложности начнуться когда мы начнем смешивать
        std::cout << max(a, x) << std::endl;
        std::cout << max(x, a) << std::endl;
        // Тут компилятор скорее всего поругается на нас.
        // Разрешить это можно явно указав тип для функции
        std::cout << max<double>(a, x) << std::endl;
    }

Вопрос: А как компилятор отличает угловые скобки шаблона от
``operator<`` и ``operator>``.
Ответ: Из контекста.

.. code:: c++

    template <int N> {
    int AddN(int x) {
        return x + N;
    }

    int main() {
        int x = 13;
        int y = 42;
        std::cout << AddN<10>(4) << std::endl;
        // Вот такие вещи приводят к двусмысленности
        // std::cout << AddN< x > y >(4) << std::endl;
        // Поэтому стоит поставить скобки
        std::cout << AddN< (x > y) >(4) << std::endl;
    }

.. note:: Было доказано, что такой обобщенный язык полный.
    Следовательно можно вычислить что-нибудь хорошее на момент
    компиляции с помощью подобных конструкций.

    На некоторых олимпиадах по программированию, где не было
    условий на время компиляции, особо хитрые участники
    пользовались этим.


"На этом мы наверное и закончим... -- уже половина восьмого." А. Зобнин.



*****************************
Лекция 5
*****************************

Контейнеры
=============================

С какими-то контейнерами мы уже знакомы. Начнем с линейных или
, как говорят по другому, последовательных контейнеров. Так
называют контейнеры, которые можно представить в виде непрерывного
куска памяти.


``std::vector``
---------------
Вектор резервирует заранее достаточно большой кусок памяти
и собственно пишет в этот кусок памяти. Если места нам уже не
хватает, то происходит реаллокация:
1. Выделяется больший кусок памяти.
2. Копируется все что было в старом куске в новый.
3. Освобождаем старый.

.. note:: копирование это всегда нечто сложное, так как
    Копируемые объекты могут быть достаточно сложны по структуре.
    Так что для копирования используется специальный конструктор
    -- конструктор копирования.

Какие операции можно сделать с вектором почти бесплатно:
    * Добавление в конец (Если не нужна реаллокация).
    * Удалять с конца (Гарантируется, что стандартный вектор не
      использует реаллокацию -- сказали, что так по стандарту).
    * Доступ по элементу.

``std::list``
-------------
Список, имеется ввиду двунаправленный неинтрузивный список.

Есть специальный объект -- элемент списка. В нем есть:
1. данные
2. указатель на предыдующий элемент
3. указатель на следующий элемент

Есть обертка для элемента, который хранит все описаное выше.
Это есть неинтрузивность списка.

Оценим сложность операций:
    * добавление и удаление элемента O(1)
    * Индексация уже O(n)

Вопрос: Выделять память это же долго?
Ответ: Как работает ОС: Выделяет куски памяти по запросу.
Выделили 1, выделили 2, выделили 3...  А далее удалили 2.
Получается пустой кусок между 1 и 3(происходит фрагментация памяти).
Но есть способ перехетрить операционную систему: написать свой
менеджер памяти, который попросит большой кусок у ОС, а дальше
будет выдавать программе из своего куска место так, как нам надо.


``std::deque`` (Doulbe Ended QUEue)
-----------------------------------

Двусторонняя очередь.

Представим два вектора. Один растет влево, другой вправо.

Зная длины наших двух векторов, мы можем сравнительно легко
выполнять индексацию.

Итого, быстро:
    * push_back();
    * push_front();
    * pop_back(); // удалить с конца
    * pop_front(); // удалит с начала
    * Индексация

Но опять же не учитываем реаллокацию при добавлении элементов.
Также могут возникнуть случаи в которых оказывается пуст левый или
правый вектор и делается pop_front() или pop_back(), но это все
каким-то хитрым образом балансируется.


``std::string``
---------------

"Много функций у строки -- смотрите документацию" А. Зобнин.

Все вышеперечисленные конейнеры мы будем называть линейными
контейнерами.  Над этими линейными контейнерами, существуют
несколько адаптеров, которые используют линейные контейнеры
для своей реализации.


Адаптеры
========

``std::stack<T, необязательный параметр>``
------------------------------------------
Второй необязательный параметр -- линейный контейнер, который
будет выбран за основу для реализации.  По умолчанию это, как
ни странно, deque.

Операции:
    * void push(const T & value);
    * void pop();
    * T & top() const;
    * size_t size() const;
    * bool empty() const;

Вопрос: Почему ``pop`` возвращает ``void``? Ответ: Потому что
могут возникнуть проблемы с типом T.  Дело в том, что создание
нового объекта типа T может сам сгенерировать исключительную
ситуацию.  Проблема в универсальности. Получается несогласованное
состояние, когда ``pop`` уже удалил элемент из стека, а вернуть не
смог из за исключения.

.. note:: в деструкторах нельзя генерировать исключения
    Это было легкое и лирическое отступление.

Вопрос: Поймем почему ничего не скомпилируется если вторым параметром
отправить std::stack? Ответ: Внутри стека где-то хранится этот объект,
который является основой для стека.  Очевидно ``empty``, ``size`` --
просто возвращают то, что возвращает основа.  А ведь ``push``, должен
вызвать ``push_back``. У стека такой функции нет.  Кстати,
соответственно, ``pop`` -- ``pop_back()``, ``top`` -- ``back()``.


``std::queue<T, необязательный уже знакомый нам параметр>``
-----------------------------------------------------------
Тоже сделан на основе std::deque

``std::priority_queue<T, необязательная основа>``
-------------------------------------------------
Дефолтный необязательный контейнер ``vector<T>`` по версии
http://cplusplus.com. Реализация очереди с приоритетами.

Адаптеры закончились.



Нелинейные (ассоциативные) контейнеры
=====================================
Список ассоциативных (нелинейных) контейнеров.
    * ``std::map``
      Реализация на красночерных деревьях
    * ``std::multimap``
    * ``std::set``
      map в котором игнорируются все значения -- одни ключи.
    * ``std::multiset``

В C++11 включили ``std::unordered_map`` и ``std::unordered_set``.
А в старом стандарте забыли включить хэш таблицы, чем по сути
является ``unordered_map``.


Итераторы
=========

Мы посмотрели на то какие бывают контейнеры, а нам нужно еще
узнать то, какие бывают итераторы.

Итераторы бывают разные, очевидно, что для вектора и для списка
они должны отличаться.

*Random Access iterator* (итератор произвольного доступа):
    * ``it + 10;``
    * ``it - 2;``
    * ``it[8];``
    * ``it1 - it2;``

Например: ``deque``, ``vector``, ``string``... все, что с произвольным
доступом.

*Bidirectional iterator* (Двунаправленный итератор):
    * ``++it; it++;``
    * ``--it; it--;``

``it + 1`` уже нельзя.
Пример: ``std::list``.

Вопрос: А у map итераторы какого тип? Ответ: У map кстати
``bidirectional``.

*Forward iterator* (Однонаправленный итератор)
    * ``++it; it++;``
    * ``*it``

На этом действия с forward iterator закончились. Но есть еще более
простые итераторы.


*Input и Output iterator* (Итераторы ввода и итераторы вывода).
Представьте себе, что у вас не контейнер, а какой либо поток.
Нам надо прочитать текущий символ, чтобы прочитать дальше.
Причем, если мы прочитали(считали с итератора), то он сдвинется
дальше и прочитать то, что уже было снова не получится.

    * ``*it; // И после того как он вернет текущее, сдвинется
      на следующее.``
    * ``it->something; // Пока еще не прошли, поэтому умолчали.``
    * ``it1 != it2;``
    * ``it++; ++it; // формально есть, но скорее ничего не
      делает. Хотя, зависит от реализации.``


Алгоритмы
=========
Сами по себе контейнеры не особо полезны. Было бы полезно иметь
алгоритмы работающие на этих контейнерах.

Естесственно алгоритмы тоже хочется написать обобщенно.  Эти
алгоритмы будут использовать не сами объекты, а неких посредников
чтобы работать с контейнерами -- это итераторы.

Например хотим ``sort`` для итераторов произвольного доступа.
Нам нужны границы.

Напишем функцию ``copy``, несмотря на то, что такая есть в
стандартной библиотеке.

.. code:: c++

    template <typename T, typename R>
    R copy(T begin, T end, R dest) {
        while(begin != end) {
            * dest++ = * begin++;
        }

        return dest;
    }

    // Как использовать

    int a[10]; // как то заполненный
    std::vector<int> b(10);
    list<int> c(10);

    std::copy(a, a + 10, b.begin());
    std::copy(b.begin(), b.end(), c);
    std::copy(c.begin(), c.end(), a);
    std::copy(c.rbegin(), c.rend(), a); // Перевернули последовательность!

.. note:: Мы можем даже посылать input и output итераторы!
    Именно чтобы такой код работал для input и output итераторов
    ++ ничего для них делает(просто фиктивно существует).


****************************
Лекция 6.
****************************

Сегодня мы будем изучать классы. "Классы будем изучать с примера на
котором все изучают классы -- это комплексные числа." А. Зобнин.

Классы
======

Класс
    это такой пользовательский тип данных, или совокупность методов
    и полей.  Он реализует интерфейс для последующего использования
    объектов этого типа.

.. code:: c++

    class badComplex {
        public:
        double x, y;
    };
    // На этом можно было бы остановиться

    int main() {
        badComplex z;
        z.x = 1;
        z.y = -2;

        badComplex w;
        // Но мы не умеем
        // z + w;
        // std::cout << z;
        // z * 3

        // Кстати присваивать он умеет
        w = z;
        std::cout << w.x << " " << w.y << std::endl;

        // Могли бы написать еще вот так
        badComplex q = z;
        // Тут сработает конструктор копирования.
        // То есть эквивалентная запись
        // badComplex q(z);
    }


Когда мы пишем присваивание, для нас генерируется дефолтный
оператор присваивания, который присваивает каждому полю
``w`` соответствующее поле из ``z``.

Попробуем написать несколько иначе...

.. code:: c++

    class Complex {
    public:
        Complex(double a, double b) {
            std::cout << "Complex(a, b)" << std::endl;
            // Если здесь вывести x и y, то они не будут равны a и b
            x = a; // Здесь происходит присваивание, а не инициализация
            y = b;
            // Но хотелось бы тоже видеть инициализацию
        }

        // Напишем свой конструктор копирования
        Complex(const Complex& other) {
            std::cout << "Complex(other)" << std::endl;
            x = other.x;
            y = other.y;
        }
        double x, y;
    };

    int main() {
        // Теперь можно вот так!
        Complex z(1, -2);
    }

Конструктор копирования является таковым, если принимает
значение определяемого класса...(константное, не константное,
по ссылке, не по ссылке...)


Еще немного изменим наш класс.

.. code:: c++

    class Complex {
    public:
        double x, y;
        // Заменим присваивание на инициализацию
        Complex(double a, double b)
            : x(a), y(b) // КОНСТРУИРОВАНИЕ В ПОРЯДКЕ ИНИЦИАЛИЗАЦИИ!!!
        {
            std::cout << "Complex(a, b)" << std::endl;
        }

        // Делаем то же самое.
        Complex(const Complex& other)
            : x(other.x), y(other.y) 
        {
            std::cout << "Complex(other)" << std::endl;
        }
    };

Важно понять, что если мы не предоставили конструктор копирования,
или вообще конструктор. То компилятор предоставит нам их
по умолчанию.

.. tip:: Если нам не нужно какое-то особое поведение от конструкторов
    копирования и по умолчанию, то не стоит их писать. Например, с
    умными указателями нужен нетривиальный конструктор копирования.
    В большинстве задач стоит задуматься -- если не нужен, то не
    стоит его писать.

Теперь о времени жизни объектов: они уничтожаются в момент когда они
дойдут до ``}`` в блоке, в котором они были объявлены.
Когда стоит удалить объект для него вызывается *деструктор*.

Конструктор -- выполняет работу по инициализации, он может бросить
исключение если не удается создать объект. Совершенно нормально когда
он заканчивается сбоем.

Деструктор -- возвращает ресурсы системе. Деструктор должен быть
всегда безопасен так как запрашивать ресурс -- это опасно, а вернуть
-- безопасно.

.. note:: Что нибудь может пойти не так, но дать уйти исключению за
    пределы деструктора ужасно плохо. Такого не должно быть никогда!

Напишем деструктор:

.. code:: c++

    class Complex {
    public:
        double x, y;
        Complex(double a, double b)
            : x(a), y(b)
        {
            std::cout << "Complex(a, b)" << std::endl;
        }

        Complex(const Complex& other)
            : x(other.x), y(other.y)
        {
            std::cout << "Complex(other)" << std::endl;
        }

        // Знакомтесь -- деструктор.
        ~Complex() {
            std::cout << "Destructor was called!" << std::endl;
        }
    };

    int main() {
        Complex w(1, 5);
        // Можно вызвать деструктор руками;
        w.~Complex();

        // Приготовились...
    }// Oops! Мы вызываем деструктор еще раз
    // Это undefined behaviour! Не надо так делать.
    // Но существуют нужды для вызова деструктора руками
    // Об этом в следующем семестре

Вопрос: а зачем нам вообще деструктор, мы ведь в примере
только пишем в стандартный поток?
Ответ: пример с файлом:

.. code:: c++

    // Раньше с файлами работали так
    FILE * f;
    f = fopen("file.txt", "r");
    if (f == NULL) {
        // Произошел сбой -- файл не удалось открыть.
        // do something
        // Если бы мы писали класс, то тут бы кинули исключение
    }

    fscanf(f, ...);

    // А эта часть ушла бы в деструктор
    // Мы возвращаем файловый дескриптор обратно системе.
    fclose(f);

Вернемся к комплексным числам. Иногда стоит просто загнать один из
кусков программы в отдельный блок.

.. code:: c++

    int main() {
        Complex z(1, -2);
        {
            Complex w;
            w = z;
            std::cout << w.x << " " << w.y << std::endl;
        } // Деструктор w будет вызван вот здесь.
        // Его блок закончился.
        // Кстати w уже тоже будет убрана из местного пространства имен
        // Уже здесь мы не сможем обратиться к w.
        std::cout << "Finish!" << std::endl;
    }

Кстати, можно и так:

.. code:: c++

    int main() {
        Complex z(1, -2);
        {
            Complex z(10, 10);
            std::cout << z.x << std::endl;
            // Выведет 10
            std::cout << ::z.x << std::endl;
            // Выведет 1
        }
    }


Напишем оператор для сложения двух комплексных чисел:

.. code:: c++

    class Complex {
    public:
        double x, y;
        Complex(double a, double b)
            : x(a), y(b)
        {
            std::cout << "Complex(a, b)" << std::endl;
        }

        Complex(const Complex& other)
            : x(other.x), y(other.y)
        {
            std::cout << "Complex(other)" << std::endl;
        }

        // Добавим небольшую функцию
        double Re() const {
            return x;
        }

        Complex operator + (const Complex& z) const {
            return Complex(x + z.x, y + z.y);
        }

        ~Complex() {
            std::cout << "Destructor was called!" << std::endl;
        }
    };

Сама функция ``operator+`` не изменяет своих слогаемых, поэтому
стоит объявить ее константной (поставить const после объявления
сигнатуры)

Как уже говорилось раньше: сначала принято писать ``operator+=``,
а через него уже ``operator+``:

.. code:: c++

    class Complex {
    public:
        double x, y;
        Complex(double a, double b)
            : x(a), y(b)
        {
            std::cout << "Complex(a, b)" << std::endl;
        }

        Complex(const Complex& other)
            : x(other.x), y(other.y)
        {
            std::cout << "Complex(other)" << std::endl;
        }

        Complex& operator += (const Complex& z) {
            x += z.x;
            y += z.y;
            return * this;
        }

        Complex operator + (const Complex& z) const {
            Complex result(* this);
            return result += z;
        }

        ~Complex() {
            std::cout << "Destructor was called!" << std::endl;
        }
    };


Как перегрузить префиксный и постфиксный ``++``?

.. code:: c++

    class Complex {
    public:
        double x, y;
        Complex(double a, double b)
            : x(a), y(b)
        {
            std::cout << "Complex(a, b)" << std::endl;
        }

        Complex(const Complex& other)
            : x(other.x), y(other.y)
        {
            std::cout << "Complex(other)" << std::endl;
        }

        Complex& operator += (const Complex& z) {
            x += z.x;
            y += z.y;
            return * this;
        }

        Complex operator + (const Complex& z) const {
            Complex result(* this);
            return result += z;
        }

        // Префиксный! ++C
        Complex& operator++() {
            ++x;
            return * this;
        }

        // Постфиксный! С++;
        Complex operator++(int) {
            Complex old(* this);
            ++x;
            return old;
        }

        ~Complex() {
            std::cout << "Destructor was called!" << std::endl;
        }
    };

Ну и напоследок напишем вывод на экран:

.. code:: c++

    std::ostream& operator<< (std::ostream & out, const Complex & z) {
        out << z.x << " + " << z.y << "i";
        return out;
    }


**************************
Лекция 7
**************************

Про что сегодня хотим рассказать? Про то, что забыли...

Перегрузка и шаблонные классы
=============================

.. code:: c++

    #include<iostream>

    // Попробуем реализовать подобие класса вектор
    template <typename T>
    class Array {
    private:
        // Такую константу
        // Нужно проинициализировать в конструкторе
        const size_t size;

        // Вот так делать не спортивно
        // std::vector<T> data;
        T * data; // Указатель на динамическую память
    public:
        Array(size_t sz)
            : size(sz) // константу можно проинициализировать
            // так и только так
            , data(new T[size])
        { }

        ~Array() {
            delete [] data;
        }
    private:
        Array & operator = (const Array & rhs);
    };


Когда мы пишем ``data = new T[size]``, мы можем попасть на исключение...
не хватило памяти, сам класс T кинул исключение... Это нормально
конструктор может закончится неудачей. Описанная конструкция монолитная
Если хотя бы один из создаваемых объектов кинул исключение, то весь
массив создастся.

Поля в конструкторе инициализируются в порядке объявления в классе.
Если мы будем делать это неправильно, то код будет потенциально опасен.

Компилятор генерирует несколько функций автоматически за нас...
Например operator=, в случае с константой он будет ругаться на то,
что не может скопировать константу.

Компилятор бы "написал" примерно следующее

.. code:: c++

    Array & operator = (const Array & rhs) {
        size = rhs.size; // Oops1 копируем константу
        data = rhs.data; // Oops2 копируем указатель
    }

Если мы воспользуемся подобным оператором = то, непонятно
кому будет принадлежать указатель на данные.

Тут нужен либо оператор = который использует глубокое копирование,
либо можно совсем запретить оператор = поместив его в
private.

В новом стандарте C++11 можно явно указать, что мы не хотим создавать
дефолтный ``operator=``.

Конструктор копирования
-----------------------
Поговорим теперь о конструкторе копирования. Тут компилятор тоже
заботливо будет генерировать конструктор копирования по умолчанию.
Написал бы он его примерно вот так:

.. code:: c++

    Array(const Array & other)
        : size(other.size)
        , data(other.data) // Oops! Создали указатель на чужие данные
    { }

Опять беда с тем кому принадлежат данные лежащие по указателю...
Допустим удаляется сначала other вместе с ним данные по указателю,
а потом созданный объект -- тут мы попадем в просак, потому что
будем пробовать освободить уже освобожденный участок памяти...
Беда...

Опять нужно либо запретить использовать конструктор копирования,
либо написать свой с глубоким копированием data. Продемонстрируем
глубокое копирование:

.. code:: c++

    Array(const Array & oter)
        : size(other.size)
    {
        data = new T[size];
        for (size_t i = 0; i != size; ++i) {
            data[i] = other.data[i];
        }
    }

Подобный код требует, чтобы у типа ``T`` существовал ``operator=``,
а также, чтобы существовал дефолтный конструктор ``T()``.

Если код не будет кидать исключений, то все будет работать корректно.
Но возникнуть исключение может при создании ``T``, при выделение памяти,
а также, что самое страшное, при работе оператора =, для типа ``T``.

Напишем более безопасную версию.

.. code:: c++

    Array(const Array & oter)
    : size(other.size)
    {
        data = new T[size];
        for (size_t i = 0; i != size; ++i) {
            try {
                data[i] = other.data[i];
            } catch(...) { // Ловим вообще все исключения.
                delete [] data;
                // Стоит также прокинуть исключение дальше.
                throw; // Прокинет то исключение, которое
                       // Было поймано с помощью catch(...)
            }
        }
    }


Динамическую память всегда нужно очищать, даже(тем более)
при сбоях!

Немного о деструкторе:
Тут нам тоже придется освобождать выделенную динамическую память.

.. code:: c++

    ~Array() {
        delete [] data;
    }

Мы свято верим в то, что операции освобождения памяти работают
безсбойно! И естесственно сами пишем такие операции --
как деструктор выше.

Если мы считаем, что какие-то действия происходящие в деструкторе
могут кинуть исключение -- то, мы обязаны не выпустить исключение
из деструктора!!! (try catch --- в руки)

Если у нас есть конструктор:

.. code:: c++

    Array(size_t sz)
        : size(sz)
        , data(new T[size])
        , dummy(0)
    { }

Проблема в том, что если ``dummy(0)`` упадет, то автоматически вызовутся
деструкторы для сначала data, потом size...
Но беда в том, что динамическую память мы не освободим, так как вызовется
деструктор для указателя, а для значения по указателю нет. Поэтому либо
надо использовать умные указатели, либо не использовать подобные
конструкции.


Оператор ``[]``
---------------

.. code:: c++

    T & operator [] (size_t i) {
        // Array<T> * const this;
        return data[i];
    }

    const T & operator [] (size_t i) const {
        // Array<T> const * const this;
        return data[i];
    }

Это две разные функции, они отличаются по сигнатуре.
Одна не позволяет изменять элемент, другая позволяет.

Как будто бы неявно в функции долетает параметр this --
указатель на сам объект.
Соответственно для константного метода:

.. code:: c++

    Array<T> const * const this;

А для не константного:

.. code:: c++

    Array<T> * const this;

Вопрос: Как компилятор их выбирает?
Ответ:

    1. Сначала пробует вызвать не константную функцию.
    2. Если не получилось -- вызывает константную.


Оператор ``=``
--------------

Есть канонический способ писать оператор =

.. code:: c++

    // Наивная версия
    Array & operator = (const Array & rhs) {
        size = rhs.size;
        delete [] data;
        data = new T[size];
        // ...
    }

Этот код плох потому что может быть присваевание самому себе.
В таком случае мы сначала удалим данные, а потом попробуем
копировать уже удаленные данные.

.. code:: c++

    // Менее наивная версия
    Array & operator = (const Array & rhs) {
        if (&rhs == this) { // Именно поэтому не стоит перегружать &
            return * this;
        }
        size = rhs.size;
        delete [] data;
        data = new T[size];
        // ...
    }

Но хорошо бы не дублировать код, а воспользоваться тем, что уже
написано.

.. code:: c++

    void swap(Array & rhs) {
        std::swap(size, rhs.size);
        std::swap(data, rhs.data);
    }

    // Канонический вариант
    Array & operator = (const Array & rhs) {
        Array temp(rhs);
        swap(temp); // Пользуем свой swap
    } // Вызывается деструктор для temp
      // которые удаляет старые данные.

Исключения могут полезть в ``Array temp(rsh);``, но это не страшно,
так как наш объект не поменяется при этом.

Итераторы
---------
Стоит также реализовать итераторы...

.. code:: c++

    typedef T value_type;
    typedef T * iterator;
    typedef T const * const_iterator;

    const_iterator begin() const {
        return data;
    }

    const_iterator end() const {
        return data + size;
    }

    iterator begin() {
        return data;
    }

    iterator end() {
        return data + size;
    }


***************************
Лекция 8
***************************

"Мы с вами много говорили про исключения, пора бы
научиться их писать..." А. Зобнин.

Исключения
==========

Вместо тысячи слов:

.. code:: c++

    void f() {
        throw "Hello, world!";
    }

Когда функция встречает ``throw`` -- функция аварийно
завершает работу. Для этой функции после встречи
``throw`` -- работа закончена.

Обработчик исключений гарантирует, что для всех локальных
переменных, для которых мы выделили память сработает
деструктор. То есть, локальная память будет освобождена.

Проблемы возникнут в таком случае:

.. code:: c++

    void f() {
        int * a = new int [100];
        throw 1;
    }

Беда в том, что память освободится для указателя,
а динамическая память не освободится.

.. note:: Аксиома (уже не раз повторенная): все деструкторы
    не выпускают исключения наружу. Мы свято верим в то, что
    операции возвращающие ресурсы -- безсбойные.

Перехват исключений:

.. code:: c++

    try {
        f();
    } catch(int a) {
        // ...
    } catch(const std::exception &) {
        // ...
    } catch(const char * s) {
        // ...
    }


Мыслите об этом как о наборе функций с одинаковым числом
аргументов, но разным типом аргументов. Мыслите об этом
как о перегрузке.


Вопрос: Важно в каком порядке будут стоять catch?
Ответ: Да, они просматриваются сверху вниз.


Стоит наследоваться от стандартных эксепшнов.

.. code:: c++

    #include <iostream>
    #include <exception>

    class Complex;

    class MyZeroDivideException : public std::exception {
        const Complex * const numerator;
    public:
        MyZeroDivideException(const Complex * const c)
            : numerator(c)
        { }

        const Complex & getNumerator() const {
            return * numerator;
        }

        virtual const char * what() const throw() {
            return "Division by zero";
        }
    };

    class Complex() {
        // ...
        public:
        // ...
        Complex operator / (const Complex & z) const {
            if (z == 0) {
                throw MyZeroDivideException(this);
            }
        // ...
        }
        // ...
    };

    int main() {
        Complex a, b;
        try {
            a / b;
        } catch (const MyZeroDivideException & ex) {
            std::cerr << ex.what() << std::endl
                      << "Numerator: " << ex.getNumerator()
                      << std::endl;
        }
    }

Еще один вариант блока ``catch``:

.. code:: c++

    try {
    // ...
    } catch(...) {
        // Отловит все возможные исключения
    }

Оператор приведения типа
------------------------
"Еще одна штука про которую я не успел рассказать..." А. Зобнин.

.. code:: c++

    complex z;
    // Хочется уметь вот так
    double a = (double) z;


    class Complex() {
        // ...
        public:
        // ...

        // Пишется очень просто
        operator double () const {
            // Например хочу модуль числа вернуть
            return sqrt(x*x + y*y);
        }

        // ...
        }
        // ...
    };

Как быстро реализовывать итераторы?
-----------------------------------
Каждый уважающий себя итератор (реализующий стандартный интерфейс
итераторов) имеет серию ``typedef``-ов:

.. code:: c++

    typedef T value_type;
    typedef T * pointer;
    typedef T & reference;
    // typedefs for iterator_category, difference_type... etc

Каждый раз писать подобное утомительно, поэтому лучше наследоваться.

.. code:: c++

    #include <iterator>

    template <typename T>
    class MyIterator
            : public std::iterator<T, std::random_access_iterator_tag> {
        // typedef std::random_access_iterator_tag iterator_category;
        // typedef T value_type;
        // typedef ptrdiff_t difference_type;
        // ...
    };

Рассмотрим следующий пример:

.. code:: c++

    // Расстояние между итераторами
    // Которое будет работать не только
    // для random_access_iterator
    template <typename Iter>
    size_t dist(Iter a, Iter b) {
        size_t counter = 0;
        while (a != b) {
            ++counter;
            ++a;
        }
        return counter;
        return b - a; // Вариант для random_access_iterator
    }

    int main() {
        std::vector<int> v;
        std::list<int> l;

        distance(v.begin(), v.end());

        // Эта строка со вторым ретерном не скомпилируется.
        distance(l.begin(), l.end());
    }

Но это ведь не хорошо, когда мы для ``random_access_iterator`` будем
за не константное время сообщать расстояние, тем не менее мы хотим, чтобы
наша функция работала и для ``bidirectional_iterator`` (которые у
``std::list``).

Решение этой проблемы:

.. code:: c++

    template <typename Iter, typename Category>
    size_t distance_impl(Iter a, Iter b, Category) {
        size_t counter = 0;
        while (a != b) {
            ++counter;
            ++a;
        }
        return counter;
    }

    template <typename Iter>
    size_t distance_impl(
        Iter a,
        Iter b,
        std::random_access_iterator_tag
    ) {
        return b - a;
    }

    template <typename Iter>
    size_t dist(Iter a, Iter b) {
        return distance_impl
                (a, b, typename Iter::iterator_category());
    }

Но и это еще не все! Давайте научим нашу функцию работать ещще и
с указателями:

.. code:: c++

    template <typename Iter>
    size_t distance(Iter a, Iter b) {
        return distance_impl(Iter a, Iter b,
            typename std::iterator_traits<Iter>::iterator_category());
    }

Почему это работает? Все очень просто, для ``iterator_traits`` есть
*спецификация* для указателей. То есть для указателей она работает по
одному, а для итераторов по другому. Примерно так:

.. code:: c++

    template <typename Iter>
    struct iterator_traits {
        typedef typename Iter::iterator_category iterator_category;
    };

    // Более специализированная версия для указателей
    template <typename T>
    struct iterator_traits<T*> {
        typedef std::random_access_iterator_tag iterator_category;
    };

    // Надо бы еще константную реализацию...
    template <typename T>
    struct iterator_traits<T * const> {
        typedef std::random_access_iterator_tag iterator_category;
    };

    // Может понадобиться volatile


``volatile`` мы можем написать везде, где можно написать ``const``:
вместо ``const`` или рядом с ``const``. Это означает, что переменная
не будет храниться в регистре процессора -- у нее будет честный
адрес в памяти.



***********************
Лекция 9
***********************

Забытые темы
======================

Опасные конструкции
-------------------
``mutable``
    ключевое слово которое позволяет менять
    поле даже у константного объекта. Опасная
    конструкция.

``const_cast``
    еще одна опасная конструкция -- снимает константность.

.. note:: Такими вещами не стоит злоупотреблять. Если они
    используются массово, то надо задуматься о правильности
    архитектуры.

Статические переменные
----------------------
Что еще можно объявить в классе? Статические переменные.

.. code:: c++

    template <typename T = doube>
    class A {
        static int counter;
    };

    // Нужно определить переменную вне класса
    template <typename T>
    int A::counter = 0;


    int main() {
        A<int>::counter += 10;

        A::counter += 11;

        std::cout << A<double>::counter << std::endl;
        // 11

        std::cout << A<int>::counter << std::endl;
        // 10
    }

Вопрос: можно ли статическую переменную объявить в классе?
Ответ: если она простого типа, то можно.

Специализация шаблона
---------------------
.. code:: c++

    template <typename T>
    struct C {
        typedef int X;
    };

    template <>
    struct C<double> {
        static double X;
    }

    template <typename T1, typename T2>
    struct D {
        typedef int X;
    };

    template <typename T1>
    struct D<T1, double> {
        static double X;
    }

Пример: размер, как параметр шаблона:

.. code:: c++

    template <typename C, int N>
    class Matrix {
        // ...
    };

    Matrix<int, 10> m;

Шаблонный параметр шаблона

.. code:: c++

    Stack<typename T, typename Container> {
        // ...
    };

    // Container -- здесь есть шаблонный параметр шаблона.
    // то есть можно передать например std::vector

    Stack<int, std::vector> s;


Метапрограммирование
====================

Вычисляем степерь на этапе компиляции:

.. code:: c++

    #include <iostream>

    template <int A, int N>
    struct Power {
        static const int Result = A * Power<A, N - 1>::Result;
    };

    template <int A>
    struct Power<A, 0> {
        static const int Result = 1;
    };


    int main() {
        std::cout << Power<2, 10>::Result << std::endl;
    }

Теперь доказажем, что все это действительно происходит
на этапе компиляции.

.. code:: c++

    // Определение шаблонов Power

    template <int T>
    class Dummy;

    int main() {
        Dummy<Power<2, 10>::Result> d;
    }

Теперь линкер ругнется, что он не может найти определение
для ``Dummy<1024>``.

Следующий код не сработает.

.. code:: c++

    template <int A, int N>
    struct Power {
        // Не работает
        static const int Result =
            N > 0
            ? A * Power<A, N - 1>
            : 1;
    };

Причина не работы данной конструкции в том, что для оператора ``? :``
компилятор считает и правое и левое выражение, поэтому он достигнет
максимальной глубины стека уйдя в отрицательные ``N`` и ругнется.

Какова практическая польза?
Утверждается, что для математических библиотеки мы, к примеру,
пишем скалярное произведение. Если нам заранее известны длины
векторов, то было бы заманчиво развернуть цикл самим с помощью
шаблона. Вот такая вот микрооптимизация.


Задачи с семинара
-----------------

.. code:: c++

    // Задача:
    // Напишите функцию static_assert (не макрос).
    // Которая на этапе компиляции будет проверять
    // истинность выражения. В случае если выражение
    // равняется false, программа не должна
    // компилироваться.

    template <bool True>
    struct static_assert {
    };

    template <>
    struct static_assert<false>;

    template <int M>
    class C: static_assert<M <= 100> {
    };

    int main() {
        static_assert<2 * 2 == 5>();
        C<20> c;
        C<1000> d;

        return 0;
    }

.. code:: c++

    // Задача:
    // Напишите класс-адаптер TVector, который будет по дефолту
    // основываться на std::vector, но с перегруженным оператором
    // []. Так, что если мы выходим за границы контейнера, то
    // на возвращается дефолтное значение.

    #include <vector>
    #include <iostream>
    #include <assert.h>

    template <typename T, typename Container = std::vector<T> >
    class TVector : public Container {
        public:
        TVector() {}

        const T& operator [] (size_t index) const {
            if (index >= this->size()) {
                return T();
            }
            return this->Container::operator[](index);
        }

        T& operator [] (size_t index) {
            if (index >= this->size()) {
                this->resize(index + 1);
            }
            return this->Container::operator[](index);
        }
    };

    int main() {
        TVector<int> v;
        v.push_back(10);
        assert(v[0] == 10 && v.size() == 1 && v[10] == 0);

        v[10] = 42;
        assert(v[9] == 0 && v[10] == 42 && v.size() == 11);

        return 0;
    }

.. code:: c++

    // Задача:
    // С помощью метапрограммирования напишите конструкцию,
    // которая на этапе компиляции будет печатать все простые
    // числа от 1 до заданного числа.

    #include<stdio.h>
    #include<iostream>

    template <int N, int Div>
    struct Is {
        static const bool Prime = N % Div && Is<N, Div - 1>::Prime;
    };

    template <int N>
    struct Is<N, 1> {
        static const bool Prime = true;
    };

    template <int N>
    struct IsPrime {
        static const bool ans = Is<N, N - 1>::Prime;
    };

    template <int N, bool T>
    struct PrintIfPrime;

    template <int N>
    struct PrintIfPrime<N, false> {
        static const bool print = false;
    };

    template <int N>
    struct PrintPrime {
        static const bool print = PrintIfPrime<N, IsPrime<N>::ans>::print
                && PrintPrime<N - 1>::print;
    };

    template <>
    struct PrintPrime<1> {
        static const bool print = false;
    };

    int main() {
        PrintPrime<10>::print;
        return 0;
    }


******************************
Лекция 11
******************************
П.С. Лекции 10 просто не было, вместо нее был большой семинар.

В ``std::vector`` есть функции ``reserve``, ``resize``, ``capacity``
и ``size``. Так вот ``capacity`` -- это аллоцированная память,
поэтому ``size`` всегда меньше либо равен ``capacity``. ``reserve``
нужен для изменения ``capacity``, соответственно ``resize`` для
``size``. Так как reserve только резервирует память, но, не
определяет никаких переменных по этомй памяти, то:

.. code:: c++

    std::vector<SomeComplexType> a;
    a.reserve(10);
    a[5] = SomeComplexType(); // Неверно, так как a.size() все
                              // еще равен 0.

Выделенная память сырая, там еще нет никаких объектов -- это
логическая ошибка.

Разберем плохой код:

.. code:: c++

    for (std::vector<int>::iterator i = v.begin();
         i < v.end();
         i++
    ) {
        //... const-антные действия
    }

Поправим этот код:

.. code:: c++

    for (std::vector<int>::const_iterator i = v.begin();
         i != v.end();
         ++i
    ) {
        //...
    }

В новой версии стандарта поменяли смысл ключевого слова ``auto``:

.. code:: c++

    auto i = v.begin();

Значит "Будь добр, компилятор, догадайся сам по присваемому значению
какого типа будет ``i``"

Как работает перегрузка по константности?
Если можно вызвать неконстантную версию, то вызывается неконстантная,
а вот если нет возможности использовать неконстантной функции, то
вызывается константная функция.

Также в новой версии стандарта, чтобы избежать постоянного присвоения
неконстантного итератора(что плохо) был введен дополнительный функционал:

.. code:: c++

    auto i = v.cbegin(); // cbegin, cend -- константный begin и end


Вопрос: В чем отличие ``std::endl`` от ``'\n'``?
Ответ: ``std::endl`` дополнительно отчищает буфер,
можно это делать руками с помощью команды ``std::cout << flush;``.

Еще пример плохого кода:

.. code:: c++

    std::vector<int> v;
    v.reserve(2);
    v[0] = 1;
    std::cout << v[0]; // 1
    v.reserve(100);
    std::cout << v[0]; // 0xDEADBEEF --- или какой-нибудь
                       // другой мусор лежавший в памяти

Почему так произошло? Все очень просто: ``size`` вектора был 0,
поэтому при реаллокации ничего не скопировалось.

Проблемы возникнут также и при ситуации, когда мы позовем
``resize``, который заботливо заполнит память дефолтным значением
типа, или значением который мы укажем, при этом затерев уже
присвоенное значение.

Вопрос: а покажите нам gdb!
Ответ: Да не вопрос::

    (gdb) l                 -- напечатает текущий фрагмент программы
    (gdb) b 5               -- поставить точку остановки в строке 5
    (gdb) r                 -- run program
    (gdb) p a               -- print a (напечатать переменную a)
    (gdb) n                 -- next line (выполнить следующую строчку)
    (gdb) q                 -- quit (выйти из gdb)

"Но вообще говоря наша тема сегодня это алгоритмы стандартной
библиотеки." А. Зобнин.

Алгоритмы стандартной библиотеки
================================

Напишем несколько способов вывода на экран элементов
контейнера

.. code:: c++

    #include <iostream>
    #include <deque>

    int main() {
        std::deque<int> d(10);
        for (size_t i = 0; i != 10; ++i)
            d[i] = i;

        print(d);
    }

Напишем этот самый ``print``:

.. code:: c++

    // variant 1
    // Работает только для контейнеров с произвольным доступом
    template <typename C>
    void print(const C& cont) {
        for (size_t i = 0; i != cont.size(); ++i)
            std::cout << cont[i] << " ";
    }

.. code:: c++

    // variant 2
    // Хотя бы форвард итераторы, фактически для всех
    template <typename C>
    void print(const C& cont) {
        for (typename C::const_iterator it = cont.begin();
             it != cont.end(); ++it)
            std::cout << cont[i] << " ";
    }

.. code:: c++

    // variant 3
    // for_each
    #include <algorithm>
    template <typename T>
    void printElement(const T& elem) {
        std::cout << elem << " ";
    }

    template <typename C>
    void print(const C& cont) {

        std::for_each(cont.begin(), cont.end(),
                printElement<typename C::value_type>);
        // К несчастью сам фор ич не поймет какой шаблонный
        // параметр у printElement

        std::cout << std::endl;
    }

.. code:: c++

    // Как бы мы сами написали for_each
    template <typename Iter, typename F>
    void our_for_each(Iter a, Iter b, F f) {
        while (a != b) {
            f(* a);
            ++a;
        }
    }

    // "Я вам обещал написать функтор" А. Зобнин.
    template <typename T>
    struct printElemFunctor {
        void operator () (const T& elem) const {
            std::cout << elem << " ";
        }
    };


    template <typename C>
    void print(const C& cont) {

        std::for_each(cont.begin(), cont.end(),
                printElemFunctor());
        // А вот функтор умеет сам подбирать тип.

        std::cout << std::endl;
    }

На деле ``for_each`` возвращает не ``void``, а переданный ему функтор.

.. code:: c++

    // Variant 4
    // Заключительный..
    template <typename C>
    void print(const C& cont) {
        std::copy(
            cont.begin(),
            cont.end(),
            std::ostream_iterator<typename C::value_type>(std::cout, " ")
        );
    }


    // Вдохновленные примером 4 пишем
    #include <iterator>
    int main() {
        std::deque<int> d;

        std::copy(
            std::istream_iterator<int>(std::cin),
            std::istream_iterator<int>(),
            std::back_inserter(d)  // когда присаивают, делает push_back()
        );

        // можно ведь так std::deque<int> d2(d.begin(), d.end());
        // а значит можно попробовать и вот так
        // std::deque<int> d2(
        //     std::istream_iterator<int>(cin),
        //     std::istream_iterator<int>()
        // );
        // Но не работает! Почему?
        // ... тишина
        // Компилятор считает, что d2 это не deque, а функция.
        // Он интерпретирует это как:
        // std::deque<int> d2(
        //     std::istream_iterator<int> cin,
        //     std::istream_iterator<int> kakaya_to_bezimyannaya_func()
        // );

        std::copy(
            d.begin(),
            d.end(),
            std::ostream_iterator<int>(std::cout, " ")
        );

        return 0;
    }


*************************
Лекция 12
*************************

И снова о классах
=================

В классе мы можем писать три области доступа:

.. code:: c++

    class C {
    private:    // Видно только классу
        // ...
    protected:  // Видно наследникам
        // ...
    public:     // Видно всем (интерфейс)
        // ...
    };

Хорошим тоном является описывать в ``public`` интерфейс,
а данные скрывать в ``private``

Что может быть в классе?

.. code:: c++

    class C {
    private:
        int a;
        std::vector<int> v;

    protected:
        typedef int TInt;
        void f() connst {

        }

        friend void g();    // Дружественная функция
                            // Получает доступ к внутренним
                            // полям класса.

    public:
        class D { };
    };

Наследование
------------

Например мы хотим написать класс D, который похож на
класс C, но мы хотим дополнить этот класс D.

.. code:: c++

    class D: public C {
        //...
    };


Бывают три модификатора наследования:
    * public
    * private (default)
    * protected

Этот модификатор на область доступа в классе наследнике.

``public``
    "считается, что в наследнике D храниться "подобъект" класса C."
    (c) А. Зобнин.

    ``private`` поля не видны в наследнике,
    ``protected`` поля сохраняют статус ``protected``,
    ``public`` сохраняют статус ``public``.

.. code:: c++

    class C {
    private:
        int a;
        std::vector<int> v;
    public:
        double d;
    };

    class D: public C {
    public:
        void h() {
            // Нам видны все переменные и функции класса С, как свои.
            // Кроме private полей.
        }
    };

.. note::

    Как в виде данных представляется вектор?
    Вектор есть три указателя(обычно):

        * начало выделенного куска памяти
        * конец выделенного куска памяти
        * конец заполненной области.


``private``
    "``private`` поля вообще не видны, а ``public`` и ``protected`` поля
    становятся private в наследнике." А. Зобнин.


``protected``
    "``private`` поля вообще не видны, ``protected`` видны и сохраняют
    статус ``protected``, ``public`` получают статус ``protected``
    в наследнике.'


Простой пример:

.. code:: c++

    class C {
    protected:
        void f() { }
    };

    class D: public C { };

    class E: public C {
    public:
        using C::f;
    };

    int main() {
        D d;
        d.f();  // Не получится f сохранит статус protected

        E e;
        e.f();  // А это уже сработает!
    }


Таким образом класс наследник может изменить область доступа
наследованных полей. (Выдать поля своих родителей)

Приведенный выше антипаттерн называют "public Morozoff". Не стоит
писать такой код.

Более легкий пример. Иерархия геометрических фигур:

.. code:: c++

    // Например есть цвет
    class Figure {
    protected:
        int Colour;

    public:
        void Draw() const;
    };

    class Ellipse: public Figure {
    protected:
        double X1, Y1, X2, Y2, e;
    };

    class Circle: public Figure {
    protected:
        double X, Y;
        double Radius;
    };

    class Triangle: public Figure k
    protected:
        double X1, Y1, X2, Y2, X3, Y3;
    };

    // Правильный треугольник... будем пробовать?
    class RightTriangle: public Triangle {
        // Может быть мы неправильно выбрали иерархию наследования.
    };


    int main() {
        RightTriangle tr;
        tr.Draw();
    }

"Открытое наследование -- это отношение 'является'" А. Зобнин.

.. tip:: "предпочитайте композицию наследованию"


Каким правилом компилятор находит имена в иерархиях --
    1. Ищет имя в самом возможном узком классе
    2. Ищет по параметром подходящее **имя** в найденном классе
    3. Смотрим на модификатор доступа (можно ли воспользоваться)

Пример для понимания:

.. code:: c++

    class A {
    public:
        f(int);
    };

    class B: public A {
    private:
        f(int);
    };

    class C: public B { };

    int main() {
        C c;
        C.f(5); // ошибка компиляции
    }

или

.. code:: c++

    class A {
    public:
        f(int);
    };
    class B: public A {
    public:
        f(const std::vector<int> & v);
        f(const std::list<int> & l);
    };

    class C: public B { };

    int main() {
        C c;
        C.f(int(5)); // ошибка компиляции
    }

Примеры показывают, что сначала компилятор ищет именно **имя** в иерархии
наследовании. Нашел класс с этим именем, а уже после этого в найденном
классе пробует найти функцию с подходящей сигнатурой.

``virtual``
-----------
Идем к виртуальности:

.. code:: c++

    #include <iostream>

    class Figure {
    protected:
        int Colour;

    public:
        // Определим после ошибок в main ниже
        virtual void Draw() const {
            std::cout << "BASE DRAW" << std::endl;
        }
    };

    class Ellipse: public Figure {
    protected:
        double X1, Y1, X2, Y2, e;
    };

    class Circle: public Figure {
    protected:
        double X, Y;
        double Radius;

    public:
        void Draw() {
            std::cout << "O" << std::endl;
        }
    };

    class Triangle: public Figure {
    protected:
        double X1, Y1, X2, Y2, X3, Y3;

    public:
        void Draw() const {
            std::cout << "Triangle!" << std::endl;
        }
    };

    class RightTriangle: public Triangle {
    public:
        void Draw() const {
            std::cout << "Right Triangle!" << std::endl;
        }
    };

    int main() {
        RightTriangle tr;
        tr.Draw();  // "Right Triangle!"

        Figure& f = tr;
        f.Draw(); // Ошибка линковки.
        // После того как мы определим Figure::Draw() const
        // f.Draw() вызовет из базового класса.
        // А после того как мы определим virtual Figure::Draw() const;
        // Вызовется Rigth triangle.
    }

Заметим, что мы применили ``virtual`` только в базовом классе.

Если в классе есть ``virtual`` функция, то в него добавится указатель на
таблицу виртуальных функций (а именно на нужную реализацию виртуальной
функции). С помощью ``sizeof`` можно увидеть, что размер у одного и того
же класса с виртуальными и не виртуальными функциями разный.

О вызове конструкторов:
    1. Вызывается самый верхний в иерархии класс
    2. и далее все ниже и ниже по лестнице иерархии до нашего класса.

Каждый конструктор на деле изменяет наш "виртуальный" указатель, таким
образом заставляя правильно указывать на функцию фактически созданного
класса.

Пример с вызовами конструкторов:

.. code:: c++

    class A {
    public:
        A() {
            std::cout << "A!";
        }
    };

    class B : public A {
    public:
        B() {
            std::cout << "B!";
        }
    };

    class C : public B {
    public:
        C() {
            std::cout << "C!";
        }
    };

    int main() {
        C c; // на экране: A!B!C!
        A a = c; // на экране пусто, так как
        // вызвался конструктор копирования.
    }

Пример с вектором указателем на фигуры:

.. code:: c++

    // ... Предыдущее описание фируг

    int main() {
        std::vector<Figure*> figures;
        figures.push_back(new Circle);
        figures.push_back(new RightTriangle);
        figures.push_back(new Triangle);

        for (size_t = 0; i != figures.size(); ++i) {
            figures[i]->Draw();
            delete figures[i];  // Oops! не виртуальный деструктор!
        }
    }

    // Результат работы:
    // O
    // Right Triangle!
    // Triangle!


Но есть огромная проблема! Вызывается не виртуальный деструктор,
мы вызываем деструктор для базового класса.

Поправим код. Также лучше чтобы у базового класса была функция
``Draw``, но чтоб она не существовала:

.. code:: c++

    class Figure {
    public:
        // Для этого объявим чисто виртуальную функцию.
        // pure virtual function
        virtual void Draw() const = 0;
        virtual ~Figure() {
        }
    };

О чем тут еще стоит сказать:
Есть ведь еще и шаблоны: полиморфизм времени компиляции
Когда виртуальные функции: полиморфизм времени исполнения.

Вот так можно "полиморфировать" во время компиляции.

.. code:: c++

    template <typename F>
    void DrawIt(const F& object) {
        object.Draw();
    }

Но вектор создать не получится... только если не ``void*``, а это
не очень хорошо, придется сырую память потом правильно приводить.

Бывает и множественное наследование, но об этом несколько позже.


