===================================
Лекции по курсу С++. ШАД 2012-2013.
===================================

:author: Алексей Зобнин
:Student: Аман Оразаев. (aorazaev@gmail.com)


***********************************
Лекция 2.
***********************************

Операторы.
===================================

Префиксный и постфиксный инкремент
-----------------------------------
Префиксный и постфиксный инкременты -- это операторы языка. Вместо тысячи слов:

.. code:: c++

    int i = 10;
    int k = ++i;
    /// Теперь k = i = 11
    i = 10;
    k = i++;
    /// Теперь k = 10; i = 11;


Префиксный оператор возвращает ссылку на объект, в то
время как постфиксный временный объект.

.. note:: Унарный плюс для целых тоже является оператором.

Вопрос на засыпку: скомпилируются ли следующие выражения,
а если скомпилируются то, что будет происходить?

.. code:: c++

    int x = 1;
    ++++x;

.. code:: c++

    int x = 1;
    ++x++;

Вот примеры постфиксных операторов:
  ``[]``, ``()``, ``++``, ``->``, ``.``, ``::``, ``->*``, ``.*``

.. tip:: Мнемонический прием:
    Как правило, в с++ постфиксные операторы
    всегда выполняются раньше префиксных.


lvalue и rvalue
-----------------------------------
lvalue
    Под lvalue может пониматься нечто, что имеет адрес в памяти,
    причем это нечто должно быть изменяемым. Как правило lvalue
    мы можем поставить слева от оператора присваивания.

Рассмотрим пример:

.. code:: c++

   int a, b;
   a = b;

В вышепреведенном примере ``a`` не может быть объявлена константой
или константной переменной.

Вопрос на засыпку: скомпилируется ли следующий фрагмент? Если да, то что будет происходить?:

.. code:: c++

   int i = 0;
   ++i = 5;

Приоритет оператора равно ниже чем у префиксного инкремента. Поэтому сначала выполнится префиксный инкремент, вернет lvalue на i, после чего в i запишется 5.


О типах
-------
Согласно стандарту самый маленький тип -- `char`.
Все остальные типы считаются отнасительно `char`. Размер этих типов зависит от используемой платформы. Стандарт гаратнирует лишь следующее::

   char <= short int <= int <= long int <= long long int

.. note:: В 99.9% случаев размер `char` равен 1 байт.
.. tip:: В названиях типов (short|long|long long) int слово int можно не указывать.

Как правило разработчики чтобы их типы были платформонезависимы определяют свои типы вроде `i8` (`int` восьмибитный) `u16` (`unsigned` шестнадцатибитный).

Получить размер типа можно с помощью оператора `sizeof`.
Вопрос на засыпку: Чему равно следующее выражение?

.. code:: c++

   sizeof 'a';


Побитовые операторы
-------------------
Числа хранятся в виде битов, соответсвенно к ним применимы бинарные операции:

``&``
    Побитовое и.

``|``
    Побитовое или.

``xor``
    Побитовое исключающее или.

``~``
    Побитовое отрицание.

``>>`` и ``<<``
    Побитовые сдвики вправо и влево соответственно.

Знаковый бит сохраняется на своем месте, но при этом распространяется при использовании оператора сдвига.
Вопрос на засыпку: Каков будет результат выполнения следующих выражений?

.. code:: c++

   1 >> 1;
   -1 >> 1;

Пример применения побитовых операторов: проверка четности числа:

.. code:: c++

   int x = 12;
   assert(x % 2 == ~(x & 1));


О скорости работы постфиксного и префиксного инкремента
-------------------------------------------------------
Когда в качестве аргумента выступает обычная интегральная
переменная, то разницы в скорости мы не заметим, потому
что компилятор оптимизирует все за нас.

Если же мы используем какой-нибудь сложный объект,
например, итератор для контейнера, то скорее всего
компилятор не поймет что тут оптимизировать.

В нижепреведенном коде есть беда:

.. code:: c++

   std::vector<int> v = std::vector(1000);
   for (std::vector::const_iterator ci = v.begin();
        ci != v.end();
        ci++)
   {
       ci;
   }

Беда эта заключается в том, что каждый раз, когда цикл будет
выполнять постфиксный инкремент на `ci`, мы будем создавать
временный объект итератор, который нам не нужен совсем. Поэтому
правильно было бы использовать префиксный итератор.

.. tip:: Совет от классиков:
    старайтесь вообще везде использовать префиксный инкремент,
    если только это не помешает выразительности кода.

"Правильней было бы назвать язык не C++, а ++C." А. Зобнин.


Логические операторы
--------------------
Логические операторы в языке:
    ``==``, ``!=``, ``&&``, ``||``, ``>=``, ``>``, ``<=``, ``<``

Приоритет операторов сравнения выше чем у ``||`` или ``&&``.
Иногда вместо того чтобы использовать ``if`` можно воспользоваться
оператором ``? :`` (один из немногих операторов, которые нельзя
перегружать)

.. code:: c++

    session.isAuthenticated() ? doStuff(session) : session.login();

Инструкциями в языке называют условный оператор ``if``, оператор цикла
``while``, ``return`` и так далее.

.. note:: Есть такой оператор '``,``'.

    Он имеет самый низкий приоритет, бинарный. Он последовательно
    вычисляет лсначала левую часть, затем правую. Возвращает
    результат вычислений в правой части.

Хитрости с '``,``':

.. code:: c++

    int x = 10;
    int y, a, b, c
    double d;
    x > y ? (a, b, c) : d;

Вопрос: где мы можем перегружать оператор запятая?
Ответ: например класс-многочлен. Оператор запятая будет
вычислять НОД, например:

.. code:: c++

    TPolynom f, b, d;
    (f, b, d);

Если существует какой-либо бинарный оператор (условно ``@``), то
оператор ``@=`` применимо к ``a @= b`` будет обозначать ``a = a @ b``.

.. note:: Считается, что оператор ``a @= b`` быстрее чем ``a = a @ b``.
    Так как не нужно выделять дополнительной памяти для хранения
    результата.

.. tip:: Обычная практика: сначала писать оператор ``@=``, а потом
    ``a @ b`` через него. Иногда так делать не стоит (например при
    перемножении матриц так делать не стоит)

    .. code:: c++

        class ToupleOf2Ints {
        public:
            ToupleOf2Ints(int x, int y)
                : x(x)
                , y(y)
            { }

            ToupleOf2Ints(const ToupleOf2Ints& other)
                : x(other.getX())
                , y(other.getY())
            { }

            const ToupleOf2Ints& operator+=(const ToupleOf2Ints rhs) {
                x += rhs.x;
                y += rhs.y;
                return * this;
            }

            ToupleOf2Ints operator+(const ToupleOf2Ints rhs) const {
                ToupleOf2Ints copy(* this);
                return copy += rhs;
            }

        private:
            int x;
            int y;
        };

На этом разговор об операторах хотелось бы закончить.



Указатели и массивы.
====================

В двух строчках:

.. code:: c++

    int * p = 0;
    int k = 23;
    p = &k;
    assert(* p == 23);
    * p = 13;
    assert(k == 13 && * p == 13);

Массивы
-------
Массив на пальцах
    непрерывный кусок памяти в котором лежат одинаковые
    объекты. Чтобы работать с массивом, надо знаеть его
    начало (указатель на начало), поэтому указатели
    очень хорошо дружат с массивами.


Стандартный алгоритм сортировки:

.. code:: c++

    std::vector<int> k;
    /// Заполнение вектора.
    std::sort(k.begin(), k.end());

, элементы в такой сортировке будут сравниваться с помощью
стандатного оператора ``<``

Если мы хотим отсортировать как-то по другому, то нужно
писать пользовательскую функцию сравнения и передать в ``sort``
третьим, необязательным параметром.

.. code:: c++

    bool my_cmp(int lhs, int rhs) {
        return a > b;
    }

    std::vector<int> k;
    /// Заполнение вектора.
    std::sort(k.begin(), k.end(), my_cmp);


Домашнее чтение:
  - `Устройство даффа`__

.. __: http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%94%D0%B0%D1%84%D1%84%D0%B0





****************************
Лекция 3
****************************

Указатели
=========

Указатели привязаны к типу данных:

.. code:: c++

   int a = 123
   int * p = &a;

   // * p то что хранится в памяти по адресу p
   (* p)++; // Постфикс более приорететен, поэтому нужны скобки

   // Можно прибавить число
   p + 13; // указывает на 13*sizeof(int) "дальше" чем p
   p + 1;  // соседний инт
   // Собственно привет перемещению по массивам.

К примеру ``sizeof(int) == 4``, тогда память будет выглядеть вот так:

+---------------+---------------+---------------+
|     ``*p``    | ``*(p + 1)``  | ``*(p + 2)``  |
+---+---+---+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+---+

Где каждый пустой квадратик, это байт.

.. note:: ``*(p + 2)`` эквивалентно ``p[2]``, что эквивалентно
    ``*(2 + p)`` и отсюда фокус: ``2[p]`` тоже корректое выражение
    языка. Оно преобразуется в ``*(2 + p)``, но эта эквивалентность
    имеет место лишь для базовых типов.

Вернемся к объявлению:

.. code:: c++

    int * p; // Сейчас p может означать что-угодно. =>
    * (p + 2) = 0; // => Вполне может быть SEGFAULT

Работать с массивом можно, когда **на момент компиляции** известна его длина.
Это означает что шаблонная магия будет работать с массивами.

Объявим массив.

.. code:: c++

    int a[10];
    a[0] = 17; // собственно a есть указатель на первый эл-т массива.
    * a = 17;  // Абсолютно эквивалентная строчка. Тут неявно происходит
               // преобразование массива в указатель
    int * p = a + 9;
    p[-1] = 30; // обращаемся к a[8]
    a[1] = 123;
    a[9] = 222; // ОК
    a[10] = 20; // Беда!!! Скорее всего SEGFAULT

Но, стандарт гарантирует довольно неожиданную штуку:

.. code:: c++

    int b;
    int * r = a + 10; // Можно хранить вот такой указатель.
    std::sort(a, a + 10); // Отсортирует массив от начала до конца
    int * l = a + b; // если b>10 Тут стандарт ничего не гарантирует.


Этот хитрый указатель нужен чтобы обозначить конец массива.
Можно просто ориентироваться по этому ``a + arraySize`` указателю.
Разыменовывать этот указатель, к счастью, нельзя.

Между указателями допустимы операции сравнения (за константное время)
``<``, ``>``, ``<=`` и ``>=``.

Пройдем по массиву указаттелей и напечатаем элементы:

.. code:: c++

    #define arraySize 20;
    int a[arraySize];

    // version 1
    for (int i = 0; i < arraySize; ++i)
        std::cout << a[i] << " ";
    // лучше писать
    //for (int i = 0; i != arraySize; ++i)

    // version 2
    for (int * p = a; p != a + 10; ++p)
        std::cout << * p << " ";

    // Можно считать, что a(указатель на начало массива)
    // это константный указатель

    // vector version
    std::vector<int> v;
    for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); ++p)
        std::cout << * p << " ";

Понятно, что итераторы есть для всех стандартных конейнеров.
Итератор -- это отличная абстракция которая есть чтобы обходить структуру
данных. При этом она "прикидывается указателем".

const и указатели.
------------------
С помощью ``const`` можно объявить константный указатель,
указатель на константу, а еще константный указатель на константу!

.. code:: c++

    int const N = 10;
    // Легко читается справа на лево
    // "N -- константа типа инт"

    const int * p; // справа на лево "p указатель на константу типа инт"
    int const * p; // const int и int const эквивалентны
    int * const p = &b; // справа на лево "p константный указатель на инт"

    int const * const p = &b;
    // "p константный указатель на константу типа инт"
    // Можно только читать, менять нельзя НИЧЕГО
    // Ни указатель, ни то что там лежит

.. note:: Есть плохой оператор который снимает константность ``const_cast``.
    Очень не рекомендуется употреблсять это выражение.  Так что гарантии
    на константность в с++ нет. При желании все испортить -- вы все
    испортите.

``const_iterator`` -- аналог указателя на константу.

Вопрос на засыпку: как объявить итератор который является аналогом
константного указателя на нечто?

.. code:: c++

    std::vector<int> v;
    const std::vector<int>::iterator it = v.begin();

Передача аргумента по ссылке.
-----------------------------
Допустим надо передать аргумент вектор в функцию, это можно сделать
несколькими путями:

.. code:: c++

    // Наивный вариант
    void f(std::vector<int> v) {
        v[0] = 10;
    }
    // Проблема в том, что в функцию передается копия v
    // То есть с самим вектором ничего не произойдет
    // Функция будет работать только с копией
    f(v); // вектор не изменится

    // В языке C это делалось с помощью указателей
    void f_like_c(std::vector<int> * v) {
        (* v)[0] = 10
    }
    f_like_c(&v);

    // В C++ можно передавать параметр по ссылке
    // Тогда функция будет работать именно с тем
    // объектом, который мы передаем в функцию

    void f_by_ref(std::vector<int> & v) {
        v.clear();
    }
    f_by_ref(v); // Мы отчистили v

    void f_by_const_ref(const std::vector<int> & v) {
        v.clear(); // Не скомпилируется
    }
    // clear -- не константный метод
    // а у нас в аргументе константная ссылка

Тяжелые, сложные объекты стоит передавать в функцию по константной
ссылке. "Это касается чего угодно больше 8 байт" A. Зобнин.

.. note:: По сути просто передача по ссылке (у гугла в стайлгайде)
    запрещена.  Снаружи не видно, что функция может изменить объект.
    В Си-подобном случае: в вызове мы явно должны передать
    ссылку(``f(&v)``) -- так явно видно, что объект меняется.


Примеры выразительного кода
---------------------------
"Пишите как можно более выразительно!" А. Зобнин:

.. code:: c++

    int n = 10;
    while (n-->0) { // (n--) > 0
        // Шутка над тем, что n стремится к 0.
    }

.. code:: c++

    void strcpy(char * a, const char * b) {
        // variant 1
        for(;*b != 0; ++b) {
            * a = * b;
            ++a;
        }
        * a = 0;
        // получился невыразительный код

    }

    // variant 2
    void strcpy(char * a, const char * b) {
        while (* a++ = * b++); // Выразительный код!
    }

Задачка: в нижепреведенном фрагменте кода измените один символ, чтобы
программа печатала 20 плюсов:

.. code:: c++

    int i, n = 20;
    for (i = 0; i < n; --i)
        printf("+");

Ответ:

.. code:: c++

    // 3 способа
    //for(i = 0; -i < n; --i)
    //for(i = 0; i < n; --n)
    //for(i = 0; i + n; --i)


****************************
Лекция 4
****************************

Возвращаясь к предыдущей лекции приводятся канонические решения семинарских
задач. (написать свою версию ``strlen``, ``strcpy``, ``strcat``)

.. code:: c++

    #include<iostream>
    #include<string.h>

    // Чтобы исключить конфликты имен используем свой namespace
    namespace MyNamespace {
        // Будет конфликт с string.h
        // Если namespace-а не будет
        int strlen(char const * s) {
            int len = 0;
            while(* s++) ++len;
            return len;
        }

        char * strcpy(char * dest, const char * source) {
            char * oldDest = dest;
            while (* dest++ = * source++);
            return oldDest;
        }

        char * starcat(char * dest, const char * source) {
            char * oldDest = dest;
            strcpy(dest + strlen(dest), source);
        }
    }

    // Если сделать так:
    // using MyNamespace::strlen;
    // Тоже будет конфликт имен

    int main() {
        const char * s = "Hello!";
        // char * s = "Hello!"; // Не компилируется.

        char * d = new char[100];
        MyNamespace::strcpy(d, s);

        std::cout << MyNamespace::strlen(s) << std::endl;
        std::cout << d << std::endl;

        delete [] d;
    }


Функторы
========
С функциями можно работать практически как с переменными:

.. code:: c++

    // На примере уже имеющихся strcat, strlen, strcpy

    int main() {
        // Объявим указатель на функцию с такой-то сигнатурой
        char * (* f) (char * , const char * );
        // Как читать вот такую запись?
        // Скобки диктуют приоритет. А дальше читаем то что справа, потом
        // слева.  f -- это указатель на функцию с сигнатурой
        // (char * , const char * ) которая возвращает указатель на char.

        // Почувствуй разницу ;)
        char * * p [10];
        // p это массив из 10 элементов -- указателей на указатели char
        char * (* p) [10];
        // p это указатель на массив из 10 элементов -- указателей на char.

        const char * s = "Hello!";
        char * d = new char[100];

        // d = ничего
        f = MyNamespace::strcpy;
        f(d, s);
        // d = "Hello!";

        f = MyNamespace::strcat;
        f(d, s);
        // d = "Hello!Hello!";

        delete [] d;
    }

По хорошему надо бы писать:

.. code:: c++

    f = &MyNamespace::strcpy;
    (* f)(d, s);

Но язык С++ делает все за нас, поэтому можно и не делать этого.
Таким образом мы написали так называемый функтор.

Где использовать функторы? Например, когда мы пишем функцию, которая
ищеть корень монотонной функции методом дихотомии. Также вспомним
библиотечную функцию ``std::sort``, в которую можно передать
функциию которая возвращает ``bool``, которая заменит ``operator<``.
Таким образом мы сможем "отсортировать" массив как хотим.

Напишем функцию максимум:

.. code:: c++

    #include<iostream>

    int max(int a, int b) {
        return a < b ? b : a;
    }

    double max(double a, double b) {
        return a < b ? b : a;
    }

    // Так можно писать много и долго.
    // Но лучше применить шаблон
    template <typename T>
    T max(T a, T b) {
        return a < b ? b : a;
    }
    // Никакой реальный код не сгенерируется,
    // пока мы не попробуем эту функцию вызвать.

    int main() {
        int a = 1, b = 2;
        double x = 100.0, y = 43.1;

        // Компилятор сам <<подберет>> нужный нам тип.
        std::cout << max(a, b) << std::endl;
        std::cout << max(x, y) << std::endl;
        // Подберет по типу аргументов.
        // Но сложности начнуться когда мы начнем смешивать
        std::cout << max(a, x) << std::endl;
        std::cout << max(x, a) << std::endl;
        // Тут компилятор скорее всего поругается на нас.
        // Разрешить это можно явно указав тип для функции
        std::cout << max<double>(a, x) << std::endl;
    }

Вопрос: А как компилятор отличает угловые скобки шаблона от
``operator<`` и ``operator>``.
Ответ: Из контекста.

.. code:: c++

    template <int N> {
    int AddN(int x) {
        return x + N;
    }

    int main() {
        int x = 13;
        int y = 42;
        std::cout << AddN<10>(4) << std::endl;
        // Вот такие вещи приводят к двусмысленности
        // std::cout << AddN< x > y >(4) << std::endl;
        // Поэтому стоит поставить скобки
        std::cout << AddN< (x > y) >(4) << std::endl;
    }

.. note:: Было доказано, что такой обобщенный язык полный.
    Следовательно можно вычислить что-нибудь хорошее на момент
    компиляции с помощью подобных конструкций.

    На некоторых олимпиадах по программированию, где не было
    условий на время компиляции, особо хитрые участники
    пользовались этим.


"На этом мы наверное и закончим... -- уже половина восьмого." А. Зобнин.
